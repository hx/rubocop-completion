[
  {
    "version": "0.91.1",
    "diff": {
      "$schema": "http://json-schema.org/draft-07/schema",
      "title": "RuboCop configuration schema",
      "description": "Schema for RuboCop configuration files (e.g. .rubocop.yml), intended for helping IDEs provide autocompletion and validation.",
      "type": "object",
      "additionalProperties": false,
      "definitions": {
        "inherit_mode": {
          "type": "object",
          "minProperties": 1,
          "propertyNames": {
            "enum": [
              "merge",
              "override"
            ]
          },
          "additionalProperties": {
            "type": "array",
            "minItems": 1,
            "items": {
              "type": "string"
            }
          }
        },
        "listOfFiles": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "severity": {
          "type": "string",
          "enum": [
            "info",
            "refactor",
            "convention",
            "warning",
            "error",
            "fatal"
          ]
        },
        "stringOrStrings": {
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          ]
        },
        "attributeName": {
          "type": "string",
          "pattern": "^[A-Z][A-Za-z]*$"
        }
      },
      "properties": {
        "inherit_from": {
          "type": "string"
        },
        "inherit_gem": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/stringOrStrings"
          }
        },
        "require": {
          "$ref": "#/definitions/stringOrStrings"
        },
        "inherit_mode": {
          "$ref": "#/definitions/inherit_mode"
        },
        "AllCops": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "Exclude": {
              "$ref": "#/definitions/listOfFiles",
              "description": "Default: node_modules/**/*, tmp/**/*, vendor/**/*, .git/**/*"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles",
              "description": "Default: **/*.rb, **/*.arb, **/*.axlsx, **/*.builder, **/*.fcgi, **/*.gemfile, **/*.gemspec, **/*.god, **/*.jb, **/*.jbuilder, **/*.mspec, **/*.opal, **/*.pluginspec, **/*.podspec, **/*.rabl, **/*.rake, **/*.rbuild, **/*.rbw, **/*.rbx, **/*.ru, **/*.ruby, **/*.spec, **/*.thor, **/*.watchr, **/.irbrc, **/.pryrc, **/.simplecov, **/buildfile, **/Appraisals, **/Berksfile, **/Brewfile, **/Buildfile, **/Capfile, **/Cheffile, **/Dangerfile, **/Deliverfile, **/Fastfile, **/*Fastfile, **/Gemfile, **/Guardfile, **/Jarfile, **/Mavenfile, **/Podfile, **/Puppetfile, **/Rakefile, **/rakefile, **/Snapfile, **/Steepfile, **/Thorfile, **/Vagabondfile, **/Vagrantfile"
            },
            "NewCops": {
              "enum": [
                "enable",
                "disable"
              ],
              "type": "string",
              "description": "Default: pending"
            },
            "EnabledByDefault": {
              "type": "boolean",
              "description": "Default: false"
            },
            "DisabledByDefault": {
              "type": "boolean",
              "description": "Default: false"
            },
            "SuggestExtensions": {
              "type": "boolean"
            },
            "TargetRubyVersion": {
              "type": "number"
            },
            "StyleGuideBaseURL": {
              "type": "string",
              "description": "Default: https://rubystyle.guide"
            },
            "StyleGuide": {
              "type": "string"
            },
            "Enabled": {
              "type": "boolean"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "RubyInterpreters": {
              "type": "array",
              "description": "Default: ruby, macruby, rake, jruby, rbx"
            },
            "DefaultFormatter": {
              "type": "string",
              "description": "Default: progress"
            },
            "DisplayCopNames": {
              "type": "boolean",
              "description": "Default: true"
            },
            "DisplayStyleGuide": {
              "type": "boolean",
              "description": "Default: false"
            },
            "ExtraDetails": {
              "type": "boolean",
              "description": "Default: false"
            },
            "StyleGuideCopsOnly": {
              "type": "boolean",
              "description": "Default: false"
            },
            "UseCache": {
              "type": "boolean",
              "description": "Default: true"
            },
            "MaxFilesInCache": {
              "type": "integer",
              "description": "Default: 20000"
            },
            "CacheRootDirectory": {
            },
            "AllowSymlinksInCacheRootDirectory": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          }
        },
        "Bundler": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "'Bundler' department"
        },
        "Bundler/DuplicatedGem": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles",
              "description": "Default: **/*.gemfile, **/Gemfile, **/gems.rb"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "A Gem's requirements should be listed only once in a Gemfile."
        },
        "Bundler/GemComment": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles",
              "description": "Default: **/*.gemfile, **/Gemfile, **/gems.rb"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "IgnoredGems": {
              "type": "array",
              "description": "Default: []"
            },
            "OnlyFor": {
              "type": "array",
              "description": "Default: []"
            }
          },
          "description": "Add a comment describing each gem in your Gemfile.\n\nOptionally, the \"OnlyFor\" configuration can be used to only register offenses when the gems use certain options or have version specifiers. Add \"version_specifiers\" and/or the gem option names you want to check.\n\nA useful use-case is to enforce a comment when using options that change the source of a gem:\n\n - bitbucket\n\n - gist\n\n - git\n\n - github\n\n - source\n\nFor a full list of options supported by bundler, you can check the https://bundler.io/man/gemfile.5.html[official documentation]."
        },
        "Bundler/InsecureProtocolSource": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles",
              "description": "Default: **/*.gemfile, **/Gemfile, **/gems.rb"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "The symbol argument `:gemcutter`, `:rubygems`, and `:rubyforge` are deprecated. So please change your source to URL string that 'https://rubygems.org' if possible, or 'http://rubygems.org' if not.\n\nThis autocorrect will replace these symbols with 'https://rubygems.org'. Because it is secure, HTTPS request is strongly recommended. And in most use cases HTTPS will be fine.\n\nHowever, it don't replace all `sources` of `http://` with `https://`. For example, when specifying an internal gem server using HTTP on the intranet, a use case where HTTPS cannot be specified was considered. Consider using HTTP only if you cannot use HTTPS."
        },
        "Bundler/OrderedGems": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles",
              "description": "Default: **/*.gemfile, **/Gemfile, **/gems.rb"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "TreatCommentsAsGroupSeparators": {
              "type": "boolean",
              "description": "Default: true"
            },
            "ConsiderPunctuation": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "Gems should be alphabetically sorted within groups."
        },
        "Gemspec": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "'Gemspec' department"
        },
        "Gemspec/DuplicatedAssignment": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles",
              "description": "Default: **/*.gemspec"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "An attribute assignment method calls should be listed only once in a gemspec.\n\nAssigning to an attribute with the same name using `spec.foo =` will be an unintended usage. On the other hand, duplication of methods such as `spec.requirements`, `spec.add_runtime_dependency`, and others are permitted because it is the intended use of appending values."
        },
        "Gemspec/OrderedDependencies": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles",
              "description": "Default: **/*.gemspec"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "TreatCommentsAsGroupSeparators": {
              "type": "boolean",
              "description": "Default: true"
            },
            "ConsiderPunctuation": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "Dependencies in the gemspec should be alphabetically sorted."
        },
        "Gemspec/RequiredRubyVersion": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles",
              "description": "Default: **/*.gemspec"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "Checks that `required_ruby_version` of gemspec is specified and equal to `TargetRubyVersion` of .rubocop.yml. Thereby, RuboCop to perform static analysis working on the version required by gemspec."
        },
        "Gemspec/RubyVersionGlobalsUsage": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles",
              "description": "Default: **/*.gemspec"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "Checks that `RUBY_VERSION` constant is not used in gemspec. Using `RUBY_VERSION` is dangerous because value of the constant is determined by `rake release`. It's possible to have dependency based on ruby version used to execute `rake release` and not user's ruby version."
        },
        "Layout": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "'Layout' department"
        },
        "Layout/AccessModifierIndentation": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "outdent",
                "indent"
              ],
              "description": "Default: indent"
            },
            "IndentationWidth": {
              "type": "integer",
              "description": "Default: <none>"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: outdent, indent"
            }
          },
          "description": "Bare access modifiers (those not applying to specific methods) should be indented as deep as method definitions, or as deep as the class/module keyword, depending on configuration."
        },
        "Layout/ArgumentAlignment": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "with_first_argument",
                "with_fixed_indentation"
              ],
              "description": "Default: with_first_argument"
            },
            "IndentationWidth": {
              "type": "integer",
              "description": "Default: <none>"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: with_first_argument, with_fixed_indentation"
            }
          },
          "description": "Here we check if the arguments on a multi-line method definition are aligned."
        },
        "Layout/ArrayAlignment": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "with_first_element",
                "with_fixed_indentation"
              ],
              "description": "Default: with_first_element"
            },
            "IndentationWidth": {
              "type": "integer",
              "description": "Default: <none>"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: with_first_element, with_fixed_indentation"
            }
          },
          "description": "Here we check if the elements of a multi-line array literal are aligned."
        },
        "Layout/AssignmentIndentation": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "IndentationWidth": {
              "type": "integer",
              "description": "Default: <none>"
            }
          },
          "description": "This cop checks the indentation of the first line of the right-hand-side of a multi-line assignment.\n\nThe indentation of the remaining lines can be corrected with other cops such as `IndentationConsistency` and `EndAlignment`."
        },
        "Layout/BeginEndAlignment": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity",
              "description": "Default: warning"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyleAlignWith": {
              "enum": [
                "start_of_line",
                "begin"
              ],
              "description": "Default: start_of_line"
            },
            "SupportedStylesAlignWith": {
              "type": "array",
              "description": "Default: start_of_line, begin"
            }
          },
          "description": "This cop checks whether the end keyword of `begin` is aligned properly.\n\nTwo modes are supported through the `EnforcedStyleAlignWith` configuration parameter. If it's set to `start_of_line` (which is the default), the `end` shall be aligned with the start of the line where the `begin` keyword is. If it's set to `begin`, the `end` shall be aligned with the `begin` keyword.\n\n`Layout/EndAlignment` cop aligns with keywords (e.g. `if`, `while`, `case`) by default. On the other hand, `||= begin` that this cop targets tends to align with the start of the line, it defaults to `EnforcedStyleAlignWith: start_of_line`. These style can be configured by each cop."
        },
        "Layout/BlockAlignment": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyleAlignWith": {
              "enum": [
                "either",
                "start_of_block",
                "start_of_line"
              ],
              "description": "Default: either"
            },
            "SupportedStylesAlignWith": {
              "type": "array",
              "description": "Default: either, start_of_block, start_of_line"
            }
          },
          "description": "This cop checks whether the end keywords are aligned properly for do end blocks.\n\nThree modes are supported through the `EnforcedStyleAlignWith` configuration parameter:\n\n`start_of_block` : the `end` shall be aligned with the start of the line where the `do` appeared.\n\n`start_of_line` : the `end` shall be aligned with the start of the line where the expression started.\n\n`either` (which is the default) : the `end` is allowed to be in either location. The autofixer will default to `start_of_line`."
        },
        "Layout/BlockEndNewline": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks whether the end statement of a do..end block is on its own line."
        },
        "Layout/CaseIndentation": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "case",
                "end"
              ],
              "description": "Default: case"
            },
            "IndentOneStep": {
              "type": "boolean",
              "description": "Default: false"
            },
            "IndentationWidth": {
              "type": "integer",
              "description": "Default: <none>"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: case, end"
            }
          },
          "description": "This cop checks how the ``when``s of a `case` expression are indented in relation to its `case` or `end` keyword.\n\nIt will register a separate offense for each misaligned `when`."
        },
        "Layout/ClassStructure": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "Categories": {
              "description": "Default: {\"module_inclusion\"⇒[\"include\", \"prepend\", \"extend\"]}"
            },
            "ExpectedOrder": {
              "type": "array",
              "description": "Default: module_inclusion, constants, public_class_methods, initializer, public_methods, protected_methods, private_methods"
            }
          },
          "description": "Checks if the code style follows the ExpectedOrder configuration:\n\n`Categories` allows us to map macro names into a category.\n\nConsider an example of code style that covers the following order:\n\n - Module inclusion (include, prepend, extend)\n\n - Constants\n\n - Associations (has_one, has_many)\n\n - Public attribute macros (attr_accessor, attr_writer, attr_reader)\n\n - Other macros (validates, validate)\n\n - Public class methods\n\n - Initializer\n\n - Public instance methods\n\n - Protected attribute macros (attr_accessor, attr_writer, attr_reader)\n\n - Protected instance methods\n\n - Private attribute macros (attr_accessor, attr_writer, attr_reader)\n\n - Private instance methods\n\nYou can configure the following order:\n\n Layout/ClassStructure:    ExpectedOrder:      - module_inclusion      - constants      - association      - public_attribute_macros      - public_delegate      - macros      - public_class_methods      - initializer      - public_methods      - protected_attribute_macros      - protected_methods      - private_attribute_macros      - private_delegate      - private_methods\n\nInstead of putting all literals in the expected order, is also possible to group categories of macros. Visibility levels are handled automatically.\n\n Layout/ClassStructure:    Categories:      association:        - has_many        - has_one      attribute_macros:        - attr_accessor        - attr_reader        - attr_writer      macros:        - validates        - validate      module_inclusion:        - include        - prepend        - extend"
        },
        "Layout/ClosingHeredocIndentation": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "Checks the indentation of here document closings."
        },
        "Layout/ClosingParenthesisIndentation": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks the indentation of hanging closing parentheses in method calls, method definitions, and grouped expressions. A hanging closing parenthesis means `)` preceded by a line break."
        },
        "Layout/CommentIndentation": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks the indentation of comments."
        },
        "Layout/ConditionPosition": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for conditions that are not on the same line as if/while/until."
        },
        "Layout/DefEndAlignment": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity",
              "description": "Default: warning"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyleAlignWith": {
              "enum": [
                "start_of_line",
                "def"
              ],
              "description": "Default: start_of_line"
            },
            "SupportedStylesAlignWith": {
              "type": "array",
              "description": "Default: start_of_line, def"
            }
          },
          "description": "This cop checks whether the end keywords of method definitions are aligned properly.\n\nTwo modes are supported through the EnforcedStyleAlignWith configuration parameter. If it's set to `start_of_line` (which is the default), the `end` shall be aligned with the start of the line where the `def` keyword is. If it's set to `def`, the `end` shall be aligned with the `def` keyword."
        },
        "Layout/DotPosition": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "leading",
                "trailing"
              ],
              "description": "Default: leading"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: leading, trailing"
            }
          },
          "description": "This cop checks the . position in multi-line method calls."
        },
        "Layout/ElseAlignment": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks the alignment of else keywords. Normally they should be aligned with an if/unless/while/until/begin/def keyword, but there are special cases when they should follow the same rules as the alignment of end."
        },
        "Layout/EmptyComment": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "AllowBorderComment": {
              "type": "boolean",
              "description": "Default: true"
            },
            "AllowMarginComment": {
              "type": "boolean",
              "description": "Default: true"
            }
          },
          "description": "This cop checks empty comment."
        },
        "Layout/EmptyLineAfterGuardClause": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop enforces empty line after guard clause"
        },
        "Layout/EmptyLineAfterMagicComment": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "Checks for a newline after the final magic comment."
        },
        "Layout/EmptyLineAfterMultilineCondition": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "Reference": {
              "type": "array",
              "description": "Default: https://github.com/airbnb/ruby#multiline-if-newline"
            }
          },
          "description": "This cop enforces empty line after multiline condition."
        },
        "Layout/EmptyLineBetweenDefs": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "AllowAdjacentOneLineDefs": {
              "type": "boolean",
              "description": "Default: false"
            },
            "NumberOfEmptyLines": {
              "type": "integer",
              "description": "Default: 1"
            }
          },
          "description": "This cop checks whether method definitions are separated by one empty line.\n\n`NumberOfEmptyLines` can be an integer (default is 1) or an array (e.g. [1, 2]) to specify a minimum and maximum number of empty lines permitted.\n\n`AllowAdjacentOneLineDefs` configures whether adjacent one-line method definitions are considered an offense."
        },
        "Layout/EmptyLines": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for two or more consecutive blank lines."
        },
        "Layout/EmptyLinesAroundAccessModifier": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "around",
                "only_before"
              ],
              "description": "Default: around"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: around, only_before"
            },
            "Reference": {
              "type": "array",
              "description": "Default: https://edgeguides.rubyonrails.org/contributing_to_ruby_on_rails.html#follow-the-coding-conventions"
            }
          },
          "description": "Access modifiers should be surrounded by blank lines."
        },
        "Layout/EmptyLinesAroundArguments": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks if empty lines exist around the arguments of a method invocation."
        },
        "Layout/EmptyLinesAroundAttributeAccessor": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "AllowAliasSyntax": {
              "type": "boolean",
              "description": "Default: true"
            },
            "AllowedMethods": {
              "type": "array",
              "description": "Default: alias_method, public, protected, private"
            }
          },
          "description": "Checks for a newline after an attribute accessor or a group of them. `alias` syntax and `alias_method`, `public`, `protected`, and `private` methods are allowed by default. These are customizable with `AllowAliasSyntax` and `AllowedMethods` options."
        },
        "Layout/EmptyLinesAroundBeginBody": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks if empty lines exist around the bodies of begin-end blocks."
        },
        "Layout/EmptyLinesAroundBlockBody": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "empty_lines",
                "no_empty_lines"
              ],
              "description": "Default: no_empty_lines"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: empty_lines, no_empty_lines"
            }
          },
          "description": "This cop checks if empty lines around the bodies of blocks match the configuration."
        },
        "Layout/EmptyLinesAroundClassBody": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "empty_lines",
                "empty_lines_except_namespace",
                "empty_lines_special",
                "no_empty_lines",
                "beginning_only",
                "ending_only"
              ],
              "description": "Default: no_empty_lines"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: empty_lines, empty_lines_except_namespace, empty_lines_special, no_empty_lines, beginning_only, ending_only"
            }
          },
          "description": "This cop checks if empty lines around the bodies of classes match the configuration."
        },
        "Layout/EmptyLinesAroundExceptionHandlingKeywords": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks if empty lines exist around the bodies of `begin` sections. This cop doesn't check empty lines at `begin` body beginning/end and around method definition body. `Style/EmptyLinesAroundBeginBody` or `Style/EmptyLinesAroundMethodBody` can be used for this purpose."
        },
        "Layout/EmptyLinesAroundMethodBody": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks if empty lines exist around the bodies of methods."
        },
        "Layout/EmptyLinesAroundModuleBody": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "empty_lines",
                "empty_lines_except_namespace",
                "empty_lines_special",
                "no_empty_lines"
              ],
              "description": "Default: no_empty_lines"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: empty_lines, empty_lines_except_namespace, empty_lines_special, no_empty_lines"
            }
          },
          "description": "This cop checks if empty lines around the bodies of modules match the configuration."
        },
        "Layout/EndAlignment": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity",
              "description": "Default: warning"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyleAlignWith": {
              "enum": [
                "keyword",
                "variable",
                "start_of_line"
              ],
              "description": "Default: keyword"
            },
            "SupportedStylesAlignWith": {
              "type": "array",
              "description": "Default: keyword, variable, start_of_line"
            }
          },
          "description": "This cop checks whether the end keywords are aligned properly.\n\nThree modes are supported through the `EnforcedStyleAlignWith` configuration parameter:\n\nIf it's set to `keyword` (which is the default), the `end` shall be aligned with the start of the keyword (if, class, etc.).\n\nIf it's set to `variable` the `end` shall be aligned with the left-hand-side of the variable assignment, if there is one.\n\nIf it's set to `start_of_line`, the `end` shall be aligned with the start of the line where the matching keyword appears.\n\nThis `Layout/EndAlignment` cop aligns with keywords (e.g. `if`, `while`, `case`) by default. On the other hand, `Layout/BeginEndAlignment` cop aligns with `EnforcedStyleAlignWith: start_of_line` by default due to `||= begin` tends to align with the start of the line. These style can be configured by each cop."
        },
        "Layout/EndOfLine": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "EnforcedStyle": {
              "enum": [
                "native",
                "lf",
                "crlf"
              ],
              "description": "Default: native"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: native, lf, crlf"
            }
          },
          "description": "This cop checks for Windows-style line endings in the source code."
        },
        "Layout/ExtraSpacing": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "AllowForAlignment": {
              "type": "boolean",
              "description": "Default: true"
            },
            "AllowBeforeTrailingComments": {
              "type": "boolean",
              "description": "Default: false"
            },
            "ForceEqualSignAlignment": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for extra/unnecessary whitespace."
        },
        "Layout/FirstArgumentIndentation": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "consistent",
                "consistent_relative_to_receiver",
                "special_for_inner_method_call",
                "special_for_inner_method_call_in_parentheses"
              ],
              "description": "Default: special_for_inner_method_call_in_parentheses"
            },
            "IndentationWidth": {
              "type": "integer",
              "description": "Default: <none>"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: consistent, consistent_relative_to_receiver, special_for_inner_method_call, special_for_inner_method_call_in_parentheses"
            }
          },
          "description": "This cop checks the indentation of the first argument in a method call. Arguments after the first one are checked by Layout/ArgumentAlignment, not by this cop.\n\nFor indenting the first parameter of method _definitions_, check out Layout/FirstParameterIndentation."
        },
        "Layout/FirstArrayElementIndentation": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "special_inside_parentheses",
                "consistent",
                "align_brackets"
              ],
              "description": "Default: special_inside_parentheses"
            },
            "IndentationWidth": {
              "type": "integer",
              "description": "Default: <none>"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: special_inside_parentheses, consistent, align_brackets"
            }
          },
          "description": "This cop checks the indentation of the first element in an array literal where the opening bracket and the first element are on separate lines. The other elements' indentations are handled by the ArrayAlignment cop.\n\nBy default, array literals that are arguments in a method call with parentheses, and where the opening square bracket of the array is on the same line as the opening parenthesis of the method call, shall have their first element indented one step (two spaces) more than the position inside the opening parenthesis.\n\nOther array literals shall have their first element indented one step more than the start of the line where the opening square bracket is.\n\nThis default style is called 'special_inside_parentheses'. Alternative styles are 'consistent' and 'align_brackets'. Here are examples:"
        },
        "Layout/FirstArrayElementLineBreak": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for a line break before the first element in a multi-line array."
        },
        "Layout/FirstHashElementIndentation": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "special_inside_parentheses",
                "consistent",
                "align_braces"
              ],
              "description": "Default: special_inside_parentheses"
            },
            "IndentationWidth": {
              "type": "integer",
              "description": "Default: <none>"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: special_inside_parentheses, consistent, align_braces"
            }
          },
          "description": "This cop checks the indentation of the first key in a hash literal where the opening brace and the first key are on separate lines. The other keys' indentations are handled by the HashAlignment cop.\n\nBy default, Hash literals that are arguments in a method call with parentheses, and where the opening curly brace of the hash is on the same line as the opening parenthesis of the method call, shall have their first key indented one step (two spaces) more than the position inside the opening parenthesis.\n\nOther hash literals shall have their first key indented one step more than the start of the line where the opening curly brace is.\n\nThis default style is called 'special_inside_parentheses'. Alternative styles are 'consistent' and 'align_braces'. Here are examples:"
        },
        "Layout/FirstHashElementLineBreak": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for a line break before the first element in a multi-line hash."
        },
        "Layout/FirstMethodArgumentLineBreak": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for a line break before the first argument in a multi-line method call."
        },
        "Layout/FirstMethodParameterLineBreak": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for a line break before the first parameter in a multi-line method parameter definition."
        },
        "Layout/FirstParameterIndentation": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "consistent",
                "align_parentheses"
              ],
              "description": "Default: consistent"
            },
            "IndentationWidth": {
              "type": "integer",
              "description": "Default: <none>"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: consistent, align_parentheses"
            }
          },
          "description": "This cop checks the indentation of the first parameter in a method definition. Parameters after the first one are checked by Layout/ParameterAlignment, not by this cop.\n\nFor indenting the first argument of method _calls_, check out Layout/FirstArgumentIndentation, which supports options related to nesting that are irrelevant for method _definitions_."
        },
        "Layout/HashAlignment": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedHashRocketStyle": {
              "enum": [
                "key",
                "separator",
                "table"
              ],
              "description": "Default: key"
            },
            "EnforcedColonStyle": {
              "enum": [
                "key",
                "separator",
                "table"
              ],
              "description": "Default: key"
            },
            "EnforcedLastArgumentHashStyle": {
              "enum": [
                "always_inspect",
                "always_ignore",
                "ignore_implicit",
                "ignore_explicit"
              ],
              "description": "Default: always_inspect"
            },
            "AllowMultipleStyles": {
              "type": "boolean",
              "description": "Default: true"
            },
            "SupportedHashRocketStyles": {
              "type": "array",
              "description": "Default: key, separator, table"
            },
            "SupportedColonStyles": {
              "type": "array",
              "description": "Default: key, separator, table"
            },
            "SupportedLastArgumentHashStyles": {
              "type": "array",
              "description": "Default: always_inspect, always_ignore, ignore_implicit, ignore_explicit"
            }
          },
          "description": "Check that the keys, separators, and values of a multi-line hash literal are aligned according to configuration. The configuration options are:\n\n - key (left align keys, one space before hash rockets and values)\n\n - separator (align hash rockets and colons, right align keys)\n\n - table (left align keys, hash rockets, and values)\n\nThe treatment of hashes passed as the last argument to a method call can also be configured. The options are:\n\n - always_inspect\n\n - always_ignore\n\n - ignore_implicit (without curly braces)\n\nAlternatively you can specify multiple allowed styles. That's done by passing a list of styles to EnforcedStyles."
        },
        "Layout/HeredocArgumentClosingParenthesis": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for the placement of the closing parenthesis in a method call that passes a HEREDOC string as an argument. It should be placed at the end of the line containing the opening HEREDOC tag."
        },
        "Layout/HeredocIndentation": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks the indentation of the here document bodies. The bodies are indented one step.\n\nNote: When ``Layout/LineLength``'s `AllowHeredoc` is false (not default),       this cop does not add any offenses for long here documents to       avoid `Layout/LineLength`'s offenses."
        },
        "Layout/IndentationConsistency": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "normal",
                "indented_internal_methods"
              ],
              "description": "Default: normal"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: normal, indented_internal_methods"
            },
            "Reference": {
              "type": "array",
              "description": "Default: https://edgeguides.rubyonrails.org/contributing_to_ruby_on_rails.html#follow-the-coding-conventions"
            }
          },
          "description": "This cop checks for inconsistent indentation.\n\nThe difference between `indented_internal_methods` and `normal` is that the `indented_internal_methods` style prescribes that in classes and modules the `protected` and `private` modifier keywords shall be indented the same as public methods and that protected and private members shall be indented one step more than the modifiers. Other than that, both styles mean that entities on the same logical depth shall have the same indentation."
        },
        "Layout/IndentationStyle": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "IndentationWidth": {
              "type": "integer",
              "description": "Default: <none>"
            },
            "EnforcedStyle": {
              "enum": [
                "spaces",
                "tabs"
              ],
              "description": "Default: spaces"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: spaces, tabs"
            }
          },
          "description": "This cop checks that the indentation method is consistent. Either tabs only or spaces only are used for indentation."
        },
        "Layout/IndentationWidth": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "Width": {
              "type": "integer",
              "description": "Default: 2"
            },
            "IgnoredPatterns": {
              "type": "array",
              "description": "Default: []"
            }
          },
          "description": "This cop checks for indentation that doesn't use the specified number of spaces.\n\nSee also the IndentationConsistency cop which is the companion to this one."
        },
        "Layout/InitialIndentation": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for indentation of the first non-blank non-comment line in a file."
        },
        "Layout/LeadingCommentSpace": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "AllowDoxygenCommentStyle": {
              "type": "boolean",
              "description": "Default: false"
            },
            "AllowGemfileRubyComment": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks whether comments have a leading space after the `#` denoting the start of the comment. The leading space is not required for some RDoc special syntax, like `#++`, `#--`, `#:nodoc`, `=begin`- and `=end` comments, \"shebang\" directives, or rackup options."
        },
        "Layout/LeadingEmptyLines": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for unnecessary leading blank lines at the beginning of a file."
        },
        "Layout/LineLength": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Max": {
              "type": "integer",
              "description": "Default: 120"
            },
            "AllowHeredoc": {
              "type": "boolean",
              "description": "Default: true"
            },
            "AllowURI": {
              "type": "boolean",
              "description": "Default: true"
            },
            "URISchemes": {
              "type": "array",
              "description": "Default: http, https"
            },
            "IgnoreCopDirectives": {
              "type": "boolean",
              "description": "Default: true"
            },
            "IgnoredPatterns": {
              "type": "array",
              "description": "Default: []"
            }
          },
          "description": "This cop checks the length of lines in the source code. The maximum length is configurable. The tab size is configured in the `IndentationWidth` of the `Layout/IndentationStyle` cop. It also ignores a shebang line by default.\n\nThis cop has some autocorrection capabilities. It can programmatically shorten certain long lines by inserting line breaks into expressions that can be safely split across lines. These include arrays, hashes, and method calls with argument lists.\n\nIf autocorrection is enabled, the following Layout cops are recommended to further format the broken lines. (Many of these are enabled by default.)\n\n - ArgumentAlignment\n\n - BlockAlignment\n\n - BlockDelimiters\n\n - BlockEndNewline\n\n - ClosingParenthesisIndentation\n\n - FirstArgumentIndentation\n\n - FirstArrayElementIndentation\n\n - FirstHashElementIndentation\n\n - FirstParameterIndentation\n\n - HashAlignment\n\n - IndentationWidth\n\n - MultilineArrayLineBreaks\n\n - MultilineBlockLayout\n\n - MultilineHashBraceLayout\n\n - MultilineHashKeyLineBreaks\n\n - MultilineMethodArgumentLineBreaks\n\n - ParameterAlignment\n\nTogether, these cops will pretty print hashes, arrays, method calls, etc. For example, let's say the max columns is 25:"
        },
        "Layout/MultilineArrayBraceLayout": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "symmetrical",
                "new_line",
                "same_line"
              ],
              "description": "Default: symmetrical"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: symmetrical, new_line, same_line"
            }
          },
          "description": "This cop checks that the closing brace in an array literal is either on the same line as the last array element or on a new line.\n\nWhen using the `symmetrical` (default) style:\n\nIf an array's opening brace is on the same line as the first element of the array, then the closing brace should be on the same line as the last element of the array.\n\nIf an array's opening brace is on the line above the first element of the array, then the closing brace should be on the line below the last element of the array.\n\nWhen using the `new_line` style:\n\nThe closing brace of a multi-line array literal must be on the line after the last element of the array.\n\nWhen using the `same_line` style:\n\nThe closing brace of a multi-line array literal must be on the same line as the last element of the array."
        },
        "Layout/MultilineArrayLineBreaks": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop ensures that each item in a multi-line array starts on a separate line."
        },
        "Layout/MultilineAssignmentLayout": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "same_line",
                "new_line"
              ],
              "description": "Default: new_line"
            },
            "SupportedTypes": {
              "type": "array",
              "description": "Default: block, case, class, if, kwbegin, module"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: same_line, new_line"
            }
          },
          "description": "This cop checks whether the multiline assignments have a newline after the assignment operator."
        },
        "Layout/MultilineBlockLayout": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks whether the multiline do end blocks have a newline after the start of the block. Additionally, it checks whether the block arguments, if any, are on the same line as the start of the block. Putting block arguments on separate lines, because the whole line would otherwise be too long, is accepted."
        },
        "Layout/MultilineHashBraceLayout": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "symmetrical",
                "new_line",
                "same_line"
              ],
              "description": "Default: symmetrical"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: symmetrical, new_line, same_line"
            }
          },
          "description": "This cop checks that the closing brace in a hash literal is either on the same line as the last hash element, or a new line.\n\nWhen using the `symmetrical` (default) style:\n\nIf a hash's opening brace is on the same line as the first element of the hash, then the closing brace should be on the same line as the last element of the hash.\n\nIf a hash's opening brace is on the line above the first element of the hash, then the closing brace should be on the line below the last element of the hash.\n\nWhen using the `new_line` style:\n\nThe closing brace of a multi-line hash literal must be on the line after the last element of the hash.\n\nWhen using the `same_line` style:\n\nThe closing brace of a multi-line hash literal must be on the same line as the last element of the hash."
        },
        "Layout/MultilineHashKeyLineBreaks": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop ensures that each key in a multi-line hash starts on a separate line."
        },
        "Layout/MultilineMethodArgumentLineBreaks": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop ensures that each argument in a multi-line method call starts on a separate line."
        },
        "Layout/MultilineMethodCallBraceLayout": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "symmetrical",
                "new_line",
                "same_line"
              ],
              "description": "Default: symmetrical"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: symmetrical, new_line, same_line"
            }
          },
          "description": "This cop checks that the closing brace in a method call is either on the same line as the last method argument, or a new line.\n\nWhen using the `symmetrical` (default) style:\n\nIf a method call's opening brace is on the same line as the first argument of the call, then the closing brace should be on the same line as the last argument of the call.\n\nIf an method call's opening brace is on the line above the first argument of the call, then the closing brace should be on the line below the last argument of the call.\n\nWhen using the `new_line` style:\n\nThe closing brace of a multi-line method call must be on the line after the last argument of the call.\n\nWhen using the `same_line` style:\n\nThe closing brace of a multi-line method call must be on the same line as the last argument of the call."
        },
        "Layout/MultilineMethodCallIndentation": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "aligned",
                "indented",
                "indented_relative_to_receiver"
              ],
              "description": "Default: aligned"
            },
            "IndentationWidth": {
              "type": "integer",
              "description": "Default: <none>"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: aligned, indented, indented_relative_to_receiver"
            }
          },
          "description": "This cop checks the indentation of the method name part in method calls that span more than one line."
        },
        "Layout/MultilineMethodDefinitionBraceLayout": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "symmetrical",
                "new_line",
                "same_line"
              ],
              "description": "Default: symmetrical"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: symmetrical, new_line, same_line"
            }
          },
          "description": "This cop checks that the closing brace in a method definition is either on the same line as the last method parameter, or a new line.\n\nWhen using the `symmetrical` (default) style:\n\nIf a method definition's opening brace is on the same line as the first parameter of the definition, then the closing brace should be on the same line as the last parameter of the definition.\n\nIf an method definition's opening brace is on the line above the first parameter of the definition, then the closing brace should be on the line below the last parameter of the definition.\n\nWhen using the `new_line` style:\n\nThe closing brace of a multi-line method definition must be on the line after the last parameter of the definition.\n\nWhen using the `same_line` style:\n\nThe closing brace of a multi-line method definition must be on the same line as the last parameter of the definition."
        },
        "Layout/MultilineOperationIndentation": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "aligned",
                "indented"
              ],
              "description": "Default: aligned"
            },
            "IndentationWidth": {
              "type": "integer",
              "description": "Default: <none>"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: aligned, indented"
            }
          },
          "description": "This cop checks the indentation of the right hand side operand in binary operations that span more than one line.\n\nThe `aligned` style checks that operators are aligned if they are part of an `if` or `while` condition, a `return` statement, etc. In other contexts, the second operand should be indented regardless of enforced style."
        },
        "Layout/ParameterAlignment": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "with_first_parameter",
                "with_fixed_indentation"
              ],
              "description": "Default: with_first_parameter"
            },
            "IndentationWidth": {
              "type": "integer",
              "description": "Default: <none>"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: with_first_parameter, with_fixed_indentation"
            }
          },
          "description": "Here we check if the parameters on a multi-line method call or definition are aligned.\n\nTo set the alignment of the first argument, use the cop FirstParameterIndentation."
        },
        "Layout/RescueEnsureAlignment": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks whether the rescue and ensure keywords are aligned properly."
        },
        "Layout/SpaceAfterColon": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "Checks for colon (:) not followed by some kind of space. N.B. this cop does not handle spaces after a ternary operator, which are instead handled by Layout/SpaceAroundOperators."
        },
        "Layout/SpaceAfterComma": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "Checks for comma (,) not followed by some kind of space."
        },
        "Layout/SpaceAfterMethodName": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "Checks for space between a method name and a left parenthesis in defs."
        },
        "Layout/SpaceAfterNot": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for space after `!`."
        },
        "Layout/SpaceAfterSemicolon": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "Checks for semicolon (;) not followed by some kind of space."
        },
        "Layout/SpaceAroundBlockParameters": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyleInsidePipes": {
              "enum": [
                "space",
                "no_space"
              ],
              "description": "Default: no_space"
            },
            "SupportedStylesInsidePipes": {
              "type": "array",
              "description": "Default: space, no_space"
            }
          },
          "description": "Checks the spacing inside and after block parameters pipes. Line breaks inside parameter pipes are checked by `Layout/MultilineBlockLayout` and not by this cop."
        },
        "Layout/SpaceAroundEqualsInParameterDefault": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "space",
                "no_space"
              ],
              "description": "Default: space"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: space, no_space"
            }
          },
          "description": "Checks that the equals signs in parameter default assignments have or don't have surrounding space depending on configuration."
        },
        "Layout/SpaceAroundKeyword": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "Checks the spacing around the keywords."
        },
        "Layout/SpaceAroundMethodCallOperator": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "Checks method call operators to not have spaces around them."
        },
        "Layout/SpaceAroundOperators": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "AllowForAlignment": {
              "type": "boolean",
              "description": "Default: true"
            },
            "EnforcedStyleForExponentOperator": {
              "enum": [
                "space",
                "no_space"
              ],
              "description": "Default: no_space"
            },
            "SupportedStylesForExponentOperator": {
              "type": "array",
              "description": "Default: space, no_space"
            }
          },
          "description": "Checks that operators have space around them, except for ** which should or shouldn't have surrounding space depending on configuration.\n\nThis cop has `AllowForAlignment` option. When `true`, allows most uses of extra spacing if the intent is to align with an operator on the previous or next line, not counting empty lines or comment lines."
        },
        "Layout/SpaceBeforeBlockBraces": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "space",
                "no_space"
              ],
              "description": "Default: space"
            },
            "EnforcedStyleForEmptyBraces": {
              "enum": [
                "space",
                "no_space"
              ],
              "description": "Default: space"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: space, no_space"
            },
            "SupportedStylesForEmptyBraces": {
              "type": "array",
              "description": "Default: space, no_space"
            }
          },
          "description": "Checks that block braces have or don't have a space before the opening brace depending on configuration."
        },
        "Layout/SpaceBeforeComma": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "Checks for comma (,) preceded by space."
        },
        "Layout/SpaceBeforeComment": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for missing space between a token and a comment on the same line."
        },
        "Layout/SpaceBeforeFirstArg": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "AllowForAlignment": {
              "type": "boolean",
              "description": "Default: true"
            }
          },
          "description": "Checks that exactly one space is used between a method name and the first argument for method calls without parentheses.\n\nAlternatively, extra spaces can be added to align the argument with something on a preceding or following line, if the AllowForAlignment config parameter is true."
        },
        "Layout/SpaceBeforeSemicolon": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "Checks for semicolon (;) preceded by space."
        },
        "Layout/SpaceInLambdaLiteral": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "require_no_space",
                "require_space"
              ],
              "description": "Default: require_no_space"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: require_no_space, require_space"
            }
          },
          "description": "This cop checks for spaces between `->` and opening parameter parenthesis (`(`) in lambda literals."
        },
        "Layout/SpaceInsideArrayLiteralBrackets": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "space",
                "no_space",
                "compact"
              ],
              "description": "Default: no_space"
            },
            "EnforcedStyleForEmptyBrackets": {
              "enum": [
                "space",
                "no_space"
              ],
              "description": "Default: no_space"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: space, no_space, compact"
            },
            "SupportedStylesForEmptyBrackets": {
              "type": "array",
              "description": "Default: space, no_space"
            }
          },
          "description": "Checks that brackets used for array literals have or don't have surrounding space depending on configuration."
        },
        "Layout/SpaceInsideArrayPercentLiteral": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "Checks for unnecessary additional spaces inside array percent literals (i.e. %i/%w)."
        },
        "Layout/SpaceInsideBlockBraces": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "space",
                "no_space"
              ],
              "description": "Default: space"
            },
            "EnforcedStyleForEmptyBraces": {
              "enum": [
                "space",
                "no_space"
              ],
              "description": "Default: no_space"
            },
            "SpaceBeforeBlockParameters": {
              "type": "boolean",
              "description": "Default: true"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: space, no_space"
            },
            "SupportedStylesForEmptyBraces": {
              "type": "array",
              "description": "Default: space, no_space"
            }
          },
          "description": "Checks that block braces have or don't have surrounding space inside them on configuration. For blocks taking parameters, it checks that the left brace has or doesn't have trailing space depending on configuration."
        },
        "Layout/SpaceInsideHashLiteralBraces": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "space",
                "no_space",
                "compact"
              ],
              "description": "Default: space"
            },
            "EnforcedStyleForEmptyBraces": {
              "enum": [
                "space",
                "no_space"
              ],
              "description": "Default: no_space"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: space, no_space, compact"
            },
            "SupportedStylesForEmptyBraces": {
              "type": "array",
              "description": "Default: space, no_space"
            }
          },
          "description": "Checks that braces used for hash literals have or don't have surrounding space depending on configuration."
        },
        "Layout/SpaceInsideParens": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "space",
                "no_space"
              ],
              "description": "Default: no_space"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: space, no_space"
            }
          },
          "description": "Checks for spaces inside ordinary round parentheses."
        },
        "Layout/SpaceInsidePercentLiteralDelimiters": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "Checks for unnecessary additional spaces inside the delimiters of %i/%w/%x literals."
        },
        "Layout/SpaceInsideRangeLiteral": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "Checks for spaces inside range literals."
        },
        "Layout/SpaceInsideReferenceBrackets": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "space",
                "no_space"
              ],
              "description": "Default: no_space"
            },
            "EnforcedStyleForEmptyBrackets": {
              "enum": [
                "space",
                "no_space"
              ],
              "description": "Default: no_space"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: space, no_space"
            },
            "SupportedStylesForEmptyBrackets": {
              "type": "array",
              "description": "Default: space, no_space"
            }
          },
          "description": "Checks that reference brackets have or don't have surrounding space depending on configuration."
        },
        "Layout/SpaceInsideStringInterpolation": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "space",
                "no_space"
              ],
              "description": "Default: no_space"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: space, no_space"
            }
          },
          "description": "This cop checks for whitespace within string interpolations."
        },
        "Layout/TrailingEmptyLines": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "final_newline",
                "final_blank_line"
              ],
              "description": "Default: final_newline"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: final_newline, final_blank_line"
            }
          },
          "description": "This cop looks for trailing blank lines and a final newline in the source code."
        },
        "Layout/TrailingWhitespace": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "AllowInHeredoc": {
              "type": "boolean",
              "description": "Default: true"
            }
          },
          "description": "This cop looks for trailing whitespace in the source code."
        },
        "Lint": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "'Lint' department"
        },
        "Lint/AmbiguousBlockAssociation": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for ambiguous block association with method when param passed without parentheses."
        },
        "Lint/AmbiguousOperator": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for ambiguous operators in the first argument of a method invocation without parentheses."
        },
        "Lint/AmbiguousRegexpLiteral": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for ambiguous regexp literals in the first argument of a method invocation without parentheses."
        },
        "Lint/AssignmentInCondition": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AllowSafeAssignment": {
              "type": "boolean",
              "description": "Default: true"
            }
          },
          "description": "This cop checks for assignments in the conditions of if/while/until.\n\n`AllowSafeAssignment` option for safe assignment. By safe assignment we mean putting parentheses around an assignment to indicate \"I know I'm using an assignment as a condition. It's not a mistake.\""
        },
        "Lint/BigDecimalNew": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "`BigDecimal.new()` is deprecated since BigDecimal 1.3.3. This cop identifies places where `BigDecimal.new()` can be replaced by `BigDecimal()`."
        },
        "Lint/BinaryOperatorWithIdenticalOperands": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for places where binary operator has identical operands.\n\nIt covers arithmetic operators: `+`, `-`, `*`, `/`, `%`, `**`; comparison operators: `==`, `===`, `=~`, `>`, `>=`, `<`, `<=`; bitwise operators: `|`, `^`, `&`, `<<`, `>>`; boolean operators: `&&`, `||` and \"spaceship\" operator - `<=>`.\n\nThis cop is marked as unsafe as it does not consider side effects when calling methods and thus can generate false positives:   if wr.take_char == '\\0' && wr.take_char == '\\0'"
        },
        "Lint/BooleanSymbol": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for `:true` and `:false` symbols. In most cases it would be a typo."
        },
        "Lint/CircularArgumentReference": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for circular argument references in optional keyword arguments and optional ordinal arguments.\n\nThis cop mirrors a warning produced by MRI since 2.2."
        },
        "Lint/ConstantDefinitionInBlock": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "Do not define constants within a block, since the block's scope does not isolate or namespace the constant in any way.\n\nIf you are trying to define that constant once, define it outside of the block instead, or use a variable or method if defining the constant in the outer scope would be problematic.\n\nFor meta-programming, use `const_set`."
        },
        "Lint/ConstantResolution": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "Only": {
              "type": "array",
              "description": "Default: []"
            },
            "Ignore": {
              "type": "array",
              "description": "Default: []"
            }
          },
          "description": "Check that certain constants are fully qualified.\n\nThis is not enabled by default because it would mark a lot of offenses unnecessarily.\n\nGenerally, gems should fully qualify all constants to avoid conflicts with the code that uses the gem. Enable this cop without using `Only`/`Ignore`\n\nLarge projects will over time end up with one or two constant names that are problematic because of a conflict with a library or just internally using the same name a namespace and a class. To avoid too many unnecessary offenses, Enable this cop with `Only: [The, Constant, Names, Causing, Issues]`"
        },
        "Lint/Debugger": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for calls to debugger or pry."
        },
        "Lint/DeprecatedClassMethods": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for uses of the deprecated class method usages."
        },
        "Lint/DeprecatedOpenSSLConstant": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "Algorithmic constants for `OpenSSL::Cipher` and `OpenSSL::Digest` deprecated since OpenSSL version 2.2.0. Prefer passing a string instead."
        },
        "Lint/DisjunctiveAssignmentInConstructor": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks constructors for disjunctive assignments that should be plain assignments.\n\nSo far, this cop is only concerned with disjunctive assignment of instance variables.\n\nIn ruby, an instance variable is nil until a value is assigned, so the disjunction is unnecessary. A plain assignment has the same effect."
        },
        "Lint/DuplicateCaseCondition": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks that there are no repeated conditions used in case 'when' expressions."
        },
        "Lint/DuplicateElsifCondition": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks that there are no repeated conditions used in if 'elsif'."
        },
        "Lint/DuplicateHashKey": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for duplicated keys in hash literals.\n\nThis cop mirrors a warning in Ruby 2.2."
        },
        "Lint/DuplicateMethods": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for duplicated instance (or singleton) method definitions."
        },
        "Lint/DuplicateRequire": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for duplicate `require`s and `require_relative`s."
        },
        "Lint/DuplicateRescueException": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks that there are no repeated exceptions used in 'rescue' expressions."
        },
        "Lint/EachWithObjectArgument": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks if each_with_object is called with an immutable argument. Since the argument is the object that the given block shall make calls on to build something based on the enumerable that each_with_object iterates over, an immutable argument makes no sense. It's definitely a bug."
        },
        "Lint/ElseLayout": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for odd else block layout - like having an expression on the same line as the else keyword, which is usually a mistake."
        },
        "Lint/EmptyConditionalBody": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AllowComments": {
              "type": "boolean",
              "description": "Default: true"
            }
          },
          "description": "This cop checks for the presence of `if`, `elsif` and `unless` branches without a body."
        },
        "Lint/EmptyEnsure": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for empty `ensure` blocks"
        },
        "Lint/EmptyExpression": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for the presence of empty expressions."
        },
        "Lint/EmptyFile": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AllowComments": {
              "type": "boolean",
              "description": "Default: true"
            }
          },
          "description": "This cop enforces that Ruby source files are not empty."
        },
        "Lint/EmptyInterpolation": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for empty interpolation."
        },
        "Lint/EmptyWhen": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AllowComments": {
              "type": "boolean",
              "description": "Default: true"
            }
          },
          "description": "This cop checks for the presence of `when` branches without a body."
        },
        "Lint/EnsureReturn": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for `return` from an `ensure` block. `return` from an ensure block is a dangerous code smell as it will take precedence over any exception being raised, and the exception will be silently thrown away as if it were rescued.\n\nIf you want to rescue some (or all) exceptions, best to do it explicitly"
        },
        "Lint/ErbNewArguments": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop emulates the following Ruby warnings in Ruby 2.6.\n\n% cat example.rb ERB.new('hi', nil, '-', '@output_buffer') % ruby -rerb example.rb example.rb:1: warning: Passing safe_level with the 2nd argument of ERB.new is deprecated. Do not use it, and specify other arguments as keyword arguments. example.rb:1: warning: Passing trim_mode with the 3rd argument of ERB.new is deprecated. Use keyword argument like ERB.new(str, trim_mode:...) instead. example.rb:1: warning: Passing eoutvar with the 4th argument of ERB.new is deprecated. Use keyword argument like ERB.new(str, eoutvar: ...) instead.\n\nNow non-keyword arguments other than first one are softly deprecated and will be removed when Ruby 2.5 becomes EOL. `ERB.new` with non-keyword arguments is deprecated since ERB 2.2.0. Use `:trim_mode` and `:eoutvar` keyword arguments to `ERB.new`. This cop identifies places where `ERB.new(str, trim_mode, eoutvar)` can be replaced by `ERB.new(str, :trim_mode: trim_mode, eoutvar: eoutvar)`."
        },
        "Lint/FlipFlop": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop looks for uses of flip-flop operator. flip-flop operator is deprecated since Ruby 2.6.0."
        },
        "Lint/FloatComparison": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for the presence of precise comparison of floating point numbers.\n\nFloating point values are inherently inaccurate, and comparing them for exact equality is almost never the desired semantics. Comparison via the `==/!=` operators checks floating-point value representation to be exactly the same, which is very unlikely if you perform any arithmetic operations involving precision loss."
        },
        "Lint/FloatOutOfRange": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop identifies Float literals which are, like, really really really really really really really really big. Too big. No-one needs Floats that big. If you need a float that big, something is wrong with you."
        },
        "Lint/FormatParameterMismatch": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This lint sees if there is a mismatch between the number of expected fields for format/sprintf/#% and what is actually passed as arguments.\n\nIn addition it checks whether different formats are used in the same format string. Do not mix numbered, unnumbered, and named formats in the same format string."
        },
        "Lint/HeredocMethodCallPosition": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for the ordering of a method call where the receiver of the call is a HEREDOC."
        },
        "Lint/IdentityComparison": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "Prefer `equal?` over `==` when comparing `object_id`.\n\n`Object#equal?` is provided to compare objects for identity, and in contrast `Object#==` is provided for the purpose of doing value comparison."
        },
        "Lint/ImplicitStringConcatenation": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for implicit string concatenation of string literals which are on the same line."
        },
        "Lint/IneffectiveAccessModifier": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for `private` or `protected` access modifiers which are applied to a singleton method. These access modifiers do not make singleton methods private/protected. `private_class_method` can be used for that."
        },
        "Lint/InheritException": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "runtime_error",
                "standard_error"
              ],
              "description": "Default: runtime_error"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: runtime_error, standard_error"
            }
          },
          "description": "This cop looks for error classes inheriting from `Exception` and its standard library subclasses, excluding subclasses of `StandardError`. It is configurable to suggest using either `RuntimeError` (default) or `StandardError` instead."
        },
        "Lint/InterpolationCheck": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for interpolation in a single quoted string."
        },
        "Lint/LiteralAsCondition": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for literals used as the conditions or as operands in and/or expressions serving as the conditions of if/while/until."
        },
        "Lint/LiteralInInterpolation": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for interpolated literals."
        },
        "Lint/Loop": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for uses of `begin...end while/until something`."
        },
        "Lint/MissingCopEnableDirective": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "MaximumRangeSize": {
              "type": "number",
              "description": "Default: Infinity"
            }
          },
          "description": "This cop checks that there is an `# rubocop:enable ...` statement after a `# rubocop:disable ...` statement. This will prevent leaving cop disables on wide ranges of code, that latter contributors to a file wouldn't be aware of."
        },
        "Lint/MissingSuper": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for the presence of constructors and lifecycle callbacks without calls to `super`."
        },
        "Lint/MixedRegexpCaptureTypes": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "Do not mix named captures and numbered captures in a Regexp literal because numbered capture is ignored if they're mixed. Replace numbered captures with non-capturing groupings or named captures.\n\n  # bad\n  /(?<foo>FOO)(BAR)/\n\n  # good\n  /(?<foo>FOO)(?<bar>BAR)/\n\n  # good\n  /(?<foo>FOO)(?:BAR)/\n\n  # good\n  /(FOO)(BAR)/"
        },
        "Lint/MultipleComparison": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "In math and Python, we can use `x < y < z` style comparison to compare multiple value. However, we can't use the comparison in Ruby. However, the comparison is not syntax error. This cop checks the bad usage of comparison operators."
        },
        "Lint/NestedMethodDefinition": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for nested method definitions."
        },
        "Lint/NestedPercentLiteral": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for nested percent literals."
        },
        "Lint/NextWithoutAccumulator": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "Don't omit the accumulator when calling `next` in a `reduce` block."
        },
        "Lint/NonDeterministicRequireOrder": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "`Dir[...]` and `Dir.glob(...)` do not make any guarantees about the order in which files are returned. The final order is determined by the operating system and file system. This means that using them in cases where the order matters, such as requiring files, can lead to intermittent failures that are hard to debug. To ensure this doesn't happen, always sort the list."
        },
        "Lint/NonLocalExitFromIterator": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for non-local exits from iterators without a return value. It registers an offense under these conditions:\n\n - No value is returned,\n\n - the block is preceded by a method chain,\n\n - the block has arguments,\n\n - the method which receives the block is not define_method\nor define_singleton_method,\n\n - the return is not contained in an inner scope, e.g. a lambda or a\nmethod definition."
        },
        "Lint/NumberConversion": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "SafeAutoCorrect": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop warns the usage of unsafe number conversions. Unsafe number conversion can cause unexpected error if auto type conversion fails. Cop prefer parsing with number class instead."
        },
        "Lint/OrderedMagicComments": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "Checks the proper ordering of magic comments and whether a magic comment is not placed before a shebang."
        },
        "Lint/OutOfRangeRegexpRef": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cops looks for references of Regexp captures that are out of range and thus always returns nil."
        },
        "Lint/ParenthesesAsGroupedExpression": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "Checks for space between the name of a called method and a left parenthesis."
        },
        "Lint/PercentStringArray": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for quotes and commas in %w, e.g. `%w('foo', \"bar\")`\n\nIt is more likely that the additional characters are unintended (for example, mistranslating an array of literals to percent string notation) rather than meant to be part of the resulting strings."
        },
        "Lint/PercentSymbolArray": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for colons and commas in %i, e.g. `%i(:foo, :bar)`\n\nIt is more likely that the additional characters are unintended (for example, mistranslating an array of literals to percent string notation) rather than meant to be part of the resulting symbols."
        },
        "Lint/RaiseException": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AllowedImplicitNamespaces": {
              "type": "array",
              "description": "Default: Gem"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for `raise` or `fail` statements which are raising `Exception` class.\n\nYou can specify a module name that will be an implicit namespace using `AllowedImplicitNamespaces` option. The cop cause a false positive for namespaced `Exception` when a namespace is omitted. This option can prevent the false positive by specifying a namespace to be omitted for `Exception`. Alternatively, make `Exception` a fully qualified class name with an explicit namespace."
        },
        "Lint/RandOne": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for `rand(1)` calls. Such calls always return `0`."
        },
        "Lint/RedundantCopDisableDirective": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop detects instances of rubocop:disable comments that can be removed without causing any offenses to be reported. It's implemented as a cop in that it inherits from the Cop base class and calls add_offense. The unusual part of its implementation is that it doesn't have any on_* methods or an investigate method. This means that it doesn't take part in the investigation phase when the other cops do their work. Instead, it waits until it's called in a later stage of the execution. The reason it can't be implemented as a normal cop is that it depends on the results of all other cops to do its work."
        },
        "Lint/RedundantCopEnableDirective": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop detects instances of rubocop:enable comments that can be removed.\n\nWhen comment enables all cops at once `rubocop:enable all` that cop checks whether any cop was actually enabled."
        },
        "Lint/RedundantRequireStatement": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "Checks for unnecessary `require` statement.\n\nThe following features are unnecessary `require` statement because they are already loaded.\n\n  ruby -ve 'p $LOADED_FEATURES.reject { |feature| %r|/| =~ feature }'\n  ruby 2.2.8p477 (2017-09-14 revision 59906) [x86_64-darwin13]\n  [\"enumerator.so\", \"rational.so\", \"complex.so\", \"thread.rb\"]\n\nThis cop targets Ruby 2.2 or higher containing these 4 features."
        },
        "Lint/RedundantSplatExpansion": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for unneeded usages of splat expansion"
        },
        "Lint/RedundantStringCoercion": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for string conversion in string interpolation, which is redundant."
        },
        "Lint/RedundantWithIndex": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for redundant `with_index`."
        },
        "Lint/RedundantWithObject": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for redundant `with_object`."
        },
        "Lint/RegexpAsCondition": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for regexp literals used as `match-current-line`. If a regexp literal is in condition, the regexp matches `$_` implicitly."
        },
        "Lint/RequireParentheses": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for expressions where there is a call to a predicate method with at least one argument, where no parentheses are used around the parameter list, and a boolean operator, && or ||, is used in the last argument.\n\nThe idea behind warning for these constructs is that the user might be under the impression that the return value from the method call is an operand of &&/||."
        },
        "Lint/RescueException": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for `rescue` blocks targeting the Exception class."
        },
        "Lint/RescueType": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "Check for arguments to `rescue` that will result in a `TypeError` if an exception is raised."
        },
        "Lint/ReturnInVoidContext": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for the use of a return with a value in a context where the value will be ignored. (initialize and setter methods)"
        },
        "Lint/SafeNavigationChain": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AllowedMethods": {
              "type": "array",
              "description": "Default: present?, blank?, presence, try, try!, in?"
            }
          },
          "description": "The safe navigation operator returns nil if the receiver is nil. If you chain an ordinary method call after a safe navigation operator, it raises NoMethodError. We should use a safe navigation operator after a safe navigation operator. This cop checks for the problem outlined above."
        },
        "Lint/SafeNavigationConsistency": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "AllowedMethods": {
              "type": "array",
              "description": "Default: present?, blank?, presence, try, try!"
            }
          },
          "description": "This cop check to make sure that if safe navigation is used for a method call in an `&&` or `||` condition that safe navigation is used for all method calls on that same object."
        },
        "Lint/SafeNavigationWithEmpty": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks to make sure safe navigation isn't used with `empty?` in a conditional.\n\nWhile the safe navigation operator is generally a good idea, when checking `foo&.empty?` in a conditional, `foo` being `nil` will actually do the opposite of what the author intends."
        },
        "Lint/ScriptPermission": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks if a file which has a shebang line as its first line is granted execute permission."
        },
        "Lint/SelfAssignment": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for self-assignments."
        },
        "Lint/SendWithMixinArgument": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for `send`, `public_send`, and `__send__` methods when using mix-in.\n\n`include` and `prepend` methods were private methods until Ruby 2.0, they were mixed-in via `send` method. This cop uses Ruby 2.1 or higher style that can be called by public methods. And `extend` method that was originally a public method is also targeted for style unification."
        },
        "Lint/ShadowedArgument": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "IgnoreImplicitReferences": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for shadowed arguments.\n\nThis cop has `IgnoreImplicitReferences` configuration option. It means argument shadowing is used in order to pass parameters to zero arity `super` when `IgnoreImplicitReferences` is `true`."
        },
        "Lint/ShadowedException": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for a rescued exception that get shadowed by a less specific exception being rescued before a more specific exception is rescued."
        },
        "Lint/ShadowingOuterLocalVariable": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for the use of local variable names from an outer scope in block arguments or block-local variables. This mirrors the warning given by `ruby -cw` prior to Ruby 2.6: \"shadowing outer local variable - foo\"."
        },
        "Lint/StructNewOverride": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks unexpected overrides of the `Struct` built-in methods via `Struct.new`."
        },
        "Lint/SuppressedException": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AllowComments": {
              "type": "boolean",
              "description": "Default: true"
            }
          },
          "description": "This cop checks for `rescue` blocks with no body."
        },
        "Lint/Syntax": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop repacks Parser's diagnostics/errors into RuboCop's offenses."
        },
        "Lint/ToJSON": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks to make sure `#to_json` includes an optional argument. When overriding `#to_json`, callers may invoke JSON generation via `JSON.generate(your_obj)`.  Since `JSON#generate` allows for an optional argument, your method should too."
        },
        "Lint/TopLevelReturnWithArgument": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for top level return with arguments. If there is a top-level return statement with an argument, then the argument is always ignored. This is detected automatically since Ruby 2.7."
        },
        "Lint/TrailingCommaInAttributeDeclaration": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for trailing commas in attribute declarations, such as `#attr_reader`. Leaving a trailing comma will nullify the next method definition by overriding it with a getter method."
        },
        "Lint/UnderscorePrefixedVariableName": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AllowKeywordBlockArguments": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for underscore-prefixed variables that are actually used.\n\nSince block keyword arguments cannot be arbitrarily named at call sites, the `AllowKeywordBlockArguments` will allow use of underscore- prefixed block keyword arguments."
        },
        "Lint/UnifiedInteger": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for using Fixnum or Bignum constant."
        },
        "Lint/UnreachableCode": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for unreachable code. The check are based on the presence of flow of control statement in non-final position in `begin` (implicit) blocks."
        },
        "Lint/UnreachableLoop": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for loops that will have at most one iteration.\n\nA loop that can never reach the second iteration is a possible error in the code. In rare cases where only one iteration (or at most one iteration) is intended behavior, the code should be refactored to use `if` conditionals."
        },
        "Lint/UnusedBlockArgument": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "IgnoreEmptyBlocks": {
              "type": "boolean",
              "description": "Default: true"
            },
            "AllowUnusedKeywordArguments": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for unused block arguments."
        },
        "Lint/UnusedMethodArgument": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "AllowUnusedKeywordArguments": {
              "type": "boolean",
              "description": "Default: false"
            },
            "IgnoreEmptyMethods": {
              "type": "boolean",
              "description": "Default: true"
            },
            "IgnoreNotImplementedMethods": {
              "type": "boolean",
              "description": "Default: true"
            }
          },
          "description": "This cop checks for unused method arguments."
        },
        "Lint/UriEscapeUnescape": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop identifies places where `URI.escape` can be replaced by `CGI.escape`, `URI.encode_www_form`, or `URI.encode_www_form_component` depending on your specific use case. Also this cop identifies places where `URI.unescape` can be replaced by `CGI.unescape`, `URI.decode_www_form`, or `URI.decode_www_form_component` depending on your specific use case."
        },
        "Lint/UriRegexp": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop identifies places where `URI.regexp` is obsolete and should not be used. Instead, use `URI::DEFAULT_PARSER.make_regexp`."
        },
        "Lint/UselessAccessModifier": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "ContextCreatingMethods": {
              "type": "array",
              "description": "Default: []"
            },
            "MethodCreatingMethods": {
              "type": "array",
              "description": "Default: []"
            }
          },
          "description": "This cop checks for redundant access modifiers, including those with no code, those which are repeated, and leading `public` modifiers in a class or module body. Conditionally-defined methods are considered as always being defined, and thus access modifiers guarding such methods are not redundant.\n\nThis cop has `ContextCreatingMethods` option. The default setting value is an empty array that means no method is specified. This setting is an array of methods which, when called, are known to create its own context in the module's current access context.\n\nIt also has `MethodCreatingMethods` option. The default setting value is an empty array that means no method is specified. This setting is an array of methods which, when called, are known to create other methods in the module's current access context."
        },
        "Lint/UselessAssignment": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for every useless assignment to local variable in every scope. The basic idea for this cop was from the warning of `ruby -cw`:\n\n  assigned but unused variable - foo\n\nCurrently this cop has advanced logic that detects unreferenced reassignments and properly handles varied cases such as branch, loop, rescue, ensure, etc."
        },
        "Lint/UselessElseWithoutRescue": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for useless `else` in `begin..end` without `rescue`.\n\nThis syntax is no longer valid on Ruby 2.6 or higher and this cop is going to be removed at some point the future."
        },
        "Lint/UselessMethodDefinition": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AllowComments": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for useless method definitions, specifically: empty constructors and methods just delegating to `super`.\n\nThis cop is marked as unsafe as it can trigger false positives for cases when an empty constructor just overrides the parent constructor, which is bad anyway."
        },
        "Lint/UselessSetterCall": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for setter call to local variable as the final expression of a function definition.\n\nThere are edge cases in which the local variable references a value that is also accessible outside the local scope. This is not detected by the cop, and it can yield a false positive."
        },
        "Lint/UselessTimes": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for uses of `Integer#times` that will never yield (when the integer <= 0) or that will only ever yield once (`1.times`).\n\nThis cop is marked as unsafe as `times` returns its receiver, which is *usually* OK, but might change behavior."
        },
        "Lint/Void": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "CheckForMethodsWithNoSideEffects": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for operators, variables, literals, and nonmutating methods used in void context."
        },
        "Metrics": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "'Metrics' department"
        },
        "Metrics/AbcSize": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "IgnoredMethods": {
              "type": "array",
              "description": "Default: []"
            },
            "Max": {
              "type": "integer",
              "description": "Default: 17"
            },
            "Reference": {
              "type": "array",
              "description": "Default: http://c2.com/cgi/wiki?AbcMetric, https://en.wikipedia.org/wiki/ABC_Software_Metric"
            }
          },
          "description": "This cop checks that the ABC size of methods is not higher than the configured maximum. The ABC size is based on assignments, branches (method calls), and conditions. See http://c2.com/cgi/wiki?AbcMetric and https://en.wikipedia.org/wiki/ABC_Software_Metric."
        },
        "Metrics/BlockLength": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles",
              "description": "Default: */.gemspec"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "CountComments": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Max": {
              "type": "integer",
              "description": "Default: 25"
            },
            "CountAsOne": {
              "type": "array",
              "description": "Default: []"
            },
            "ExcludedMethods": {
              "type": "array",
              "description": "Default: refine"
            }
          },
          "description": "This cop checks if the length of a block exceeds some maximum value. Comment lines can optionally be ignored. The maximum allowed length is configurable. The cop can be configured to ignore blocks passed to certain methods.\n\nYou can set literals you want to fold with `CountAsOne`. Available are: 'array', 'hash', and 'heredoc'. Each literal will be counted as one line regardless of its actual size."
        },
        "Metrics/BlockNesting": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "CountBlocks": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Max": {
              "type": "integer",
              "description": "Default: 3"
            }
          },
          "description": "This cop checks for excessive nesting of conditional and looping constructs.\n\nYou can configure if blocks are considered using the `CountBlocks` option. When set to `false` (the default) blocks are not counted towards the nesting level. Set to `true` to count blocks as well.\n\nThe maximum level of nesting allowed is configurable."
        },
        "Metrics/ClassLength": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "CountComments": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Max": {
              "type": "integer",
              "description": "Default: 100"
            },
            "CountAsOne": {
              "type": "array",
              "description": "Default: []"
            }
          },
          "description": "This cop checks if the length a class exceeds some maximum value. Comment lines can optionally be ignored. The maximum allowed length is configurable.\n\nYou can set literals you want to fold with `CountAsOne`. Available are: 'array', 'hash', and 'heredoc'. Each literal will be counted as one line regardless of its actual size."
        },
        "Metrics/CyclomaticComplexity": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "IgnoredMethods": {
              "type": "array",
              "description": "Default: []"
            },
            "Max": {
              "type": "integer",
              "description": "Default: 7"
            }
          },
          "description": "This cop checks that the cyclomatic complexity of methods is not higher than the configured maximum. The cyclomatic complexity is the number of linearly independent paths through a method. The algorithm counts decision points and adds one.\n\nAn if statement (or unless or ?:) increases the complexity by one. An else branch does not, since it doesn't add a decision point. The && operator (or keyword and) can be converted to a nested if statement, and ||/or is shorthand for a sequence of ifs, so they also add one. Loops can be said to have an exit condition, so they add one. Blocks that are calls to builtin iteration methods (e.g. `ary.map{...}) also add one, others are ignored.\n\n  def each_child_node(*types)               # count begins: 1\n    unless block_given?                     # unless: +1\n      return to_enum(__method__, *types)\n\n  children.each do |child|                # each{}: +1\n    next unless child.is_a?(Node)         # unless: +1\n\n    yield child if types.empty? ||        # if: +1, ||: +1\n                   types.include?(child.type)\n  end\n\n    self\n  end                                       # total: 6"
        },
        "Metrics/MethodLength": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "CountComments": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Max": {
              "type": "integer",
              "description": "Default: 10"
            },
            "CountAsOne": {
              "type": "array",
              "description": "Default: []"
            },
            "ExcludedMethods": {
              "type": "array",
              "description": "Default: []"
            }
          },
          "description": "This cop checks if the length of a method exceeds some maximum value. Comment lines can optionally be ignored. The maximum allowed length is configurable.\n\nYou can set literals you want to fold with `CountAsOne`. Available are: 'array', 'hash', and 'heredoc'. Each literal will be counted as one line regardless of its actual size."
        },
        "Metrics/ModuleLength": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "CountComments": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Max": {
              "type": "integer",
              "description": "Default: 100"
            },
            "CountAsOne": {
              "type": "array",
              "description": "Default: []"
            }
          },
          "description": "This cop checks if the length a module exceeds some maximum value. Comment lines can optionally be ignored. The maximum allowed length is configurable.\n\nYou can set literals you want to fold with `CountAsOne`. Available are: 'array', 'hash', and 'heredoc'. Each literal will be counted as one line regardless of its actual size."
        },
        "Metrics/ParameterLists": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "Max": {
              "type": "integer",
              "description": "Default: 5"
            },
            "CountKeywordArgs": {
              "type": "boolean",
              "description": "Default: true"
            }
          },
          "description": "This cop checks for methods with too many parameters. The maximum number of parameters is configurable. Keyword arguments can optionally be excluded from the total count."
        },
        "Metrics/PerceivedComplexity": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "IgnoredMethods": {
              "type": "array",
              "description": "Default: []"
            },
            "Max": {
              "type": "integer",
              "description": "Default: 8"
            }
          },
          "description": "This cop tries to produce a complexity score that's a measure of the complexity the reader experiences when looking at a method. For that reason it considers `when` nodes as something that doesn't add as much complexity as an `if` or a `&&`. Except if it's one of those special `case`/`when` constructs where there's no expression after `case`. Then the cop treats it as an `if`/`elsif`/`elsif`... and lets all the `when` nodes count. In contrast to the CyclomaticComplexity cop, this cop considers `else` nodes as adding complexity."
        },
        "Migration": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "'Migration' department"
        },
        "Migration/DepartmentName": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "Check that cop names in rubocop:disable comments are given with department name."
        },
        "Naming": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "'Naming' department"
        },
        "Naming/AccessorMethodName": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop makes sure that accessor methods are named properly."
        },
        "Naming/AsciiIdentifiers": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AsciiConstants": {
              "type": "boolean",
              "description": "Default: true"
            }
          },
          "description": "This cop checks for non-ascii characters in identifier and constant names. Identifiers are always checked and whether constants are checked can be controlled using AsciiConstants config."
        },
        "Naming/BinaryOperatorParameterName": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop makes sure that certain binary operator methods have their sole  parameter named `other`."
        },
        "Naming/BlockParameterName": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "MinNameLength": {
              "type": "integer",
              "description": "Default: 1"
            },
            "AllowNamesEndingInNumbers": {
              "type": "boolean",
              "description": "Default: true"
            },
            "AllowedNames": {
              "type": "array",
              "description": "Default: []"
            },
            "ForbiddenNames": {
              "type": "array",
              "description": "Default: []"
            }
          },
          "description": "This cop checks block parameter names for how descriptive they are. It is highly configurable.\n\nThe `MinNameLength` config option takes an integer. It represents the minimum amount of characters the name must be. Its default is 1. The `AllowNamesEndingInNumbers` config option takes a boolean. When set to false, this cop will register offenses for names ending with numbers. Its default is false. The `AllowedNames` config option takes an array of permitted names that will never register an offense. The `ForbiddenNames` config option takes an array of restricted names that will always register an offense."
        },
        "Naming/ClassAndModuleCamelCase": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AllowedNames": {
              "type": "array",
              "description": "Default: module_parent"
            }
          },
          "description": "This cop checks for class and module names with an underscore in them.\n\n`AllowedNames` config takes an array of permitted names. Its default value is `['module_parent']`. These names can be full class/module names or part of the name. eg. Adding `my_class` to the `AllowedNames` config will allow names like `my_class`, `my_class::User`, `App::my_class`, `App::my_class::User`, etc."
        },
        "Naming/ConstantName": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks whether constant names are written using SCREAMING_SNAKE_CASE.\n\nTo avoid false positives, it ignores cases in which we cannot know for certain the type of value that would be assigned to a constant."
        },
        "Naming/FileName": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles",
              "description": "Default: []"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "ExpectMatchingDefinition": {
              "type": "boolean",
              "description": "Default: false"
            },
            "CheckDefinitionPathHierarchy": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Regex": {
              "description": "Default: <none>"
            },
            "IgnoreExecutableScripts": {
              "type": "boolean",
              "description": "Default: true"
            },
            "AllowedAcronyms": {
              "type": "array",
              "description": "Default: CLI, DSL, ACL, API, ASCII, CPU, CSS, DNS, EOF, GUID, HTML, HTTP, HTTPS, ID, IP, JSON, LHS, QPS, RAM, RHS, RPC, SLA, SMTP, SQL, SSH, TCP, TLS, TTL, UDP, UI, UID, UUID, URI, URL, UTF8, VM, XML, XMPP, XSRF, XSS"
            }
          },
          "description": "This cop makes sure that Ruby source files have snake_case names. Ruby scripts (i.e. source files with a shebang in the first line) are ignored.\n\nThe cop also ignores `.gemspec` files, because Bundler recommends using dashes to separate namespaces in nested gems (i.e. `bundler-console` becomes `Bundler::Console`). As such, the gemspec is supposed to be named `bundler-console.gemspec`."
        },
        "Naming/HeredocDelimiterCase": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "EnforcedStyle": {
              "enum": [
                "lowercase",
                "uppercase"
              ],
              "description": "Default: uppercase"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: lowercase, uppercase"
            }
          },
          "description": "This cop checks that your heredocs are using the configured case. By default it is configured to enforce uppercase heredocs."
        },
        "Naming/HeredocDelimiterNaming": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "ForbiddenDelimiters": {
              "enum": [
                "\\s)(EO[A-Z]{1}"
              ],
              "description": "Default: `(?-mix:(^"
            },
            "END)(\\s": {
              "type": "array",
              "description": "Default: $))`"
            }
          },
          "description": "This cop checks that your heredocs are using meaningful delimiters. By default it disallows `END` and `EO*`, and can be configured through forbidden listing additional delimiters."
        },
        "Naming/MemoizedInstanceVariableName": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "EnforcedStyleForLeadingUnderscores": {
              "enum": [
                "disallowed",
                "required",
                "optional"
              ],
              "description": "Default: disallowed"
            },
            "SupportedStylesForLeadingUnderscores": {
              "type": "array",
              "description": "Default: disallowed, required, optional"
            }
          },
          "description": "This cop checks for memoized methods whose instance variable name does not match the method name.\n\nThis cop can be configured with the EnforcedStyleForLeadingUnderscores directive. It can be configured to allow for memoized instance variables prefixed with an underscore. Prefixing ivars with an underscore is a convention that is used to implicitly indicate that an ivar should not be set or referenced outside of the memoization method."
        },
        "Naming/MethodName": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "EnforcedStyle": {
              "enum": [
                "snake_case",
                "camelCase"
              ],
              "description": "Default: snake_case"
            },
            "IgnoredPatterns": {
              "type": "array",
              "description": "Default: []"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: snake_case, camelCase"
            }
          },
          "description": "This cop makes sure that all methods use the configured style, snake_case or camelCase, for their names.\n\nThis cop has `IgnoredPatterns` configuration option.\n\n  Naming/MethodName:\n    IgnoredPatterns:\n      - '\\A\\s*onSelectionBulkChange\\s*'\n      - '\\A\\s*onSelectionCleared\\s*'\n\nMethod names matching patterns are always allowed."
        },
        "Naming/MethodParameterName": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "MinNameLength": {
              "type": "integer",
              "description": "Default: 3"
            },
            "AllowNamesEndingInNumbers": {
              "type": "boolean",
              "description": "Default: true"
            },
            "AllowedNames": {
              "type": "array",
              "description": "Default: at, by, db, id, in, io, ip, of, on, os, pp, to"
            },
            "ForbiddenNames": {
              "type": "array",
              "description": "Default: []"
            }
          },
          "description": "This cop checks method parameter names for how descriptive they are. It is highly configurable.\n\nThe `MinNameLength` config option takes an integer. It represents the minimum amount of characters the name must be. Its default is 3. The `AllowNamesEndingInNumbers` config option takes a boolean. When set to false, this cop will register offenses for names ending with numbers. Its default is false. The `AllowedNames` config option takes an array of permitted names that will never register an offense. The `ForbiddenNames` config option takes an array of restricted names that will always register an offense."
        },
        "Naming/PredicateName": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles",
              "description": "Default: spec/*/"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "NamePrefix": {
              "type": "array",
              "description": "Default: is_, has_, have_"
            },
            "ForbiddenPrefixes": {
              "type": "array",
              "description": "Default: is_, has_, have_"
            },
            "AllowedMethods": {
              "type": "array",
              "description": "Default: is_a?"
            },
            "MethodDefinitionMacros": {
              "type": "array",
              "description": "Default: define_method, define_singleton_method"
            }
          },
          "description": "This cop makes sure that predicates are named properly."
        },
        "Naming/RescuedExceptionsVariableName": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "PreferredName": {
              "type": "string",
              "description": "Default: e"
            }
          },
          "description": "This cop makes sure that rescued exceptions variables are named as expected.\n\nThe `PreferredName` config option takes a `String`. It represents the required name of the variable. Its default is `e`."
        },
        "Naming/VariableName": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "EnforcedStyle": {
              "enum": [
                "snake_case",
                "camelCase"
              ],
              "description": "Default: snake_case"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: snake_case, camelCase"
            }
          },
          "description": "This cop makes sure that all variables use the configured style, snake_case or camelCase, for their names."
        },
        "Naming/VariableNumber": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "EnforcedStyle": {
              "enum": [
                "snake_case",
                "normalcase",
                "non_integer"
              ],
              "description": "Default: normalcase"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: snake_case, normalcase, non_integer"
            }
          },
          "description": "This cop makes sure that all numbered variables use the configured style, snake_case, normalcase, or non_integer, for their numbering."
        },
        "Security": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "'Security' department"
        },
        "Security/Eval": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for the use of `Kernel#eval` and `Binding#eval`."
        },
        "Security/JSONLoad": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Reference": {
              "type": "string",
              "description": "Default: https://ruby-doc.org/stdlib-2.7.0/libdoc/json/rdoc/JSON.html#method-i-load"
            },
            "SafeAutoCorrect": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for the use of JSON class methods which have potential security issues.\n\nAutocorrect is disabled by default because it's potentially dangerous. If using a stream, like `JSON.load(open('file'))`, it will need to call `#read` manually, like `JSON.parse(open('file').read)`. If reading single values (rather than proper JSON objects), like `JSON.load('false')`, it will need to pass the `quirks_mode: true` option, like `JSON.parse('false', quirks_mode: true)`. Other similar issues may apply."
        },
        "Security/MarshalLoad": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "Reference": {
              "type": "string",
              "description": "Default: https://ruby-doc.org/core-2.7.0/Marshal.html#module-Marshal-label-Security+considerations"
            }
          },
          "description": "This cop checks for the use of Marshal class methods which have potential security issues leading to remote code execution when loading from an untrusted source."
        },
        "Security/Open": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for the use of `Kernel#open`.\n\n`Kernel#open` enables not only file access but also process invocation by prefixing a pipe symbol (e.g., `open(\"| ls\")`). So, it may lead to a serious security risk by using variable input to the argument of `Kernel#open`. It would be better to use `File.open`, `IO.popen` or `URI#open` explicitly."
        },
        "Security/YAMLLoad": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "Reference": {
              "type": "string",
              "description": "Default: https://ruby-doc.org/stdlib-2.7.0/libdoc/yaml/rdoc/YAML.html#module-YAML-label-Security"
            },
            "SafeAutoCorrect": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for the use of YAML class methods which have potential security issues leading to remote code execution when loading from an untrusted source."
        },
        "Style": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "'Style' department"
        },
        "Style/AccessModifierDeclarations": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "EnforcedStyle": {
              "enum": [
                "inline",
                "group"
              ],
              "description": "Default: group"
            },
            "AllowModifiersOnSymbols": {
              "type": "boolean",
              "description": "Default: true"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: inline, group"
            }
          },
          "description": "Access modifiers should be declared to apply to a group of methods or inline before each method, depending on configuration. EnforcedStyle config covers only method definitions. Applications of visibility methods to symbols can be controlled using AllowModifiersOnSymbols config."
        },
        "Style/AccessorGrouping": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "separated",
                "grouped"
              ],
              "description": "Default: grouped"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: separated, grouped"
            }
          },
          "description": "This cop checks for grouping of accessors in `class` and `module` bodies. By default it enforces accessors to be placed in grouped declarations, but it can be configured to enforce separating them in multiple declarations."
        },
        "Style/Alias": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "prefer_alias",
                "prefer_alias_method"
              ],
              "description": "Default: prefer_alias"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: prefer_alias, prefer_alias_method"
            }
          },
          "description": "This cop enforces the use of either `#alias` or `#alias_method` depending on configuration. It also flags uses of `alias :symbol` rather than `alias bareword`."
        },
        "Style/AndOr": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "always",
                "conditionals"
              ],
              "description": "Default: conditionals"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: always, conditionals"
            }
          },
          "description": "This cop checks for uses of `and` and `or`, and suggests using `&&` and `||` instead. It can be configured to check only in conditions or in all contexts."
        },
        "Style/ArrayCoercion": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop enforces the use of `Array()` instead of explicit `Array` check or `[*var]`."
        },
        "Style/ArrayJoin": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for uses of \"*\" as a substitute for _join_.\n\nNot all cases can reliably checked, due to Ruby's dynamic types, so we consider only cases when the first argument is an array literal or the second is a string literal."
        },
        "Style/AsciiComments": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AllowedChars": {
              "type": "array",
              "description": "Default: []"
            }
          },
          "description": "This cop checks for non-ascii (non-English) characters in comments. You could set an array of allowed non-ascii chars in AllowedChars attribute (empty by default)."
        },
        "Style/Attr": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for uses of Module#attr."
        },
        "Style/AutoResourceCleanup": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for cases when you could use a block accepting version of a method that does automatic resource cleanup."
        },
        "Style/BarePercentLiterals": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "percent_q",
                "bare_percent"
              ],
              "description": "Default: bare_percent"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: percent_q, bare_percent"
            }
          },
          "description": "This cop checks if usage of %() or %Q() matches configuration."
        },
        "Style/BeginBlock": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for BEGIN blocks."
        },
        "Style/BisectedAttrAccessor": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for places where `attr_reader` and `attr_writer` for the same method can be combined into single `attr_accessor`."
        },
        "Style/BlockComments": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop looks for uses of block comments (=begin...=end)."
        },
        "Style/BlockDelimiters": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "line_count_based",
                "semantic",
                "braces_for_chaining",
                "always_braces"
              ],
              "description": "Default: line_count_based"
            },
            "ProceduralMethods": {
              "type": "array",
              "description": "Default: benchmark, bm, bmbm, create, each_with_object, measure, new, realtime, tap, with_object"
            },
            "FunctionalMethods": {
              "type": "array",
              "description": "Default: let, let!, subject, watch"
            },
            "IgnoredMethods": {
              "type": "array",
              "description": "Default: lambda, proc, it"
            },
            "AllowBracesOnProceduralOneLiners": {
              "type": "boolean",
              "description": "Default: false"
            },
            "BracesRequiredMethods": {
              "type": "array",
              "description": "Default: []"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: line_count_based, semantic, braces_for_chaining, always_braces"
            }
          },
          "description": "Check for uses of braces or do/end around single line or multi-line blocks."
        },
        "Style/CaseEquality": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "AllowOnConstant": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for uses of the case equality operator(===)."
        },
        "Style/CaseLikeIf": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop identifies places where `if-elsif` constructions can be replaced with `case-when`."
        },
        "Style/CharacterLiteral": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "Checks for uses of the character literal ?x."
        },
        "Style/ClassAndModuleChildren": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "EnforcedStyle": {
              "enum": [
                "nested",
                "compact"
              ],
              "description": "Default: nested"
            },
            "SafeAutoCorrect": {
              "type": "boolean",
              "description": "Default: false"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: nested, compact"
            }
          },
          "description": "This cop checks the style of children definitions at classes and modules. Basically there are two different styles:\n\nThe compact style is only forced for classes/modules with one child."
        },
        "Style/ClassCheck": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "is_a?",
                "kind_of?"
              ],
              "description": "Default: is_a?"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: is_a?, kind_of?"
            }
          },
          "description": "This cop enforces consistent use of `Object#is_a?` or `Object#kind_of?`."
        },
        "Style/ClassMethods": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for uses of the class/module name instead of self, when defining class/module methods."
        },
        "Style/ClassMethodsDefinitions": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "def_self",
                "self_class"
              ],
              "description": "Default: def_self"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: def_self, self_class"
            }
          },
          "description": "This cop enforces using `def self.method_name` or `class << self` to define class methods."
        },
        "Style/ClassVars": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for uses of class variables. Offenses are signaled only on assignment to class variables to reduce the number of offenses that would be reported.\n\nYou have to be careful when setting a value for a class variable; if a class has been inherited, changing the value of a class variable also affects the inheriting classes. This means that it's almost always better to use a class instance variable instead."
        },
        "Style/CollectionMethods": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "PreferredMethods": {
              "description": "Default: {\"collect\"⇒\"map\", \"collect!\"⇒\"map!\", \"inject\"⇒\"reduce\", \"detect\"⇒\"find\", \"find_all\"⇒\"select\", \"member?\"⇒\"include?\"}"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop enforces the use of consistent method names from the Enumerable module.\n\nUnfortunately we cannot actually know if a method is from Enumerable or not (static analysis limitation), so this cop can yield some false positives.\n\nYou can customize the mapping from undesired method to desired method.\n\ne.g. to use `detect` over `find`:\n\n  Style/CollectionMethods:\n    PreferredMethods:\n      find: detect\n\nThe default mapping for `PreferredMethods` behaves as follows."
        },
        "Style/ColonMethodCall": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "\n\nThis cop checks for methods invoked via the \n\noperator instead\nof the . operator (like FileUtils::rmdir instead of FileUtils.rmdir).\n\n\n"
        },
        "Style/ColonMethodDefinition": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for class methods that are defined using the `::` operator instead of the `.` operator."
        },
        "Style/CombinableLoops": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for places where multiple consecutive loops over the same data can be combined into a single loop. It is very likely that combining them will make the code more efficient and more concise.\n\nIt is marked as unsafe, because the first loop might modify a state that the second loop depends on; these two aren't combinable."
        },
        "Style/CommandLiteral": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "backticks",
                "percent_x",
                "mixed"
              ],
              "description": "Default: backticks"
            },
            "AllowInnerBackticks": {
              "type": "boolean",
              "description": "Default: false"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: backticks, percent_x, mixed"
            }
          },
          "description": "This cop enforces using `` or %x around command literals."
        },
        "Style/CommentAnnotation": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "Keywords": {
              "type": "array",
              "description": "Default: TODO, FIXME, OPTIMIZE, HACK, REVIEW"
            }
          },
          "description": "This cop checks that comment annotation keywords are written according to guidelines."
        },
        "Style/CommentedKeyword": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for comments put on the same line as some keywords. These keywords are: `begin`, `class`, `def`, `end`, `module`.\n\nNote that some comments (`:nodoc:`, `:yields:`, `rubocop:disable` and `rubocop:todo`) are allowed."
        },
        "Style/ConditionalAssignment": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "assign_to_condition",
                "assign_inside_condition"
              ],
              "description": "Default: assign_to_condition"
            },
            "SingleLineConditionsOnly": {
              "type": "boolean",
              "description": "Default: true"
            },
            "IncludeTernaryExpressions": {
              "type": "boolean",
              "description": "Default: true"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: assign_to_condition, assign_inside_condition"
            }
          },
          "description": "Check for `if` and `case` statements where each branch is used for assignment to the same variable when using the return of the condition can be used instead."
        },
        "Style/ConstantVisibility": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks that constants defined in classes and modules have an explicit visibility declaration. By default, Ruby makes all class- and module constants public, which litters the public API of the class or module. Explicitly declaring a visibility makes intent more clear, and prevents outside actors from touching private state."
        },
        "Style/Copyright": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "Notice": {
              "type": "string",
              "description": "Default: ^Copyright (\\(c\\) )?2[0-9]{3} .+"
            },
            "AutocorrectNotice": {
              "type": "string",
              "description": "Default: ``"
            }
          },
          "description": "Check that a copyright notice was given in each source file.\n\nThe default regexp for an acceptable copyright notice can be found in config/default.yml. The default can be changed as follows:\n\n  Style/Copyright:\n    Notice: '^Copyright (\\(c\\) )?2\\d{3} Acme Inc'\n\nThis regex string is treated as an unanchored regex. For each file that RuboCop scans, a comment that matches this regex must be found or an offense is reported."
        },
        "Style/DateTime": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AllowCoercion": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for consistent usage of the `DateTime` class over the `Time` class. This cop is disabled by default since these classes, although highly overlapping, have particularities that make them not replaceable in certain situations when dealing with multiple timezones and/or DST."
        },
        "Style/DefWithParentheses": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for parentheses in the definition of a method, that does not take any arguments. Both instance and class/singleton methods are checked."
        },
        "Style/Dir": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for places where the `#__dir__` method can replace more complex constructs to retrieve a canonicalized absolute path to the current file."
        },
        "Style/DisableCopsWithinSourceCodeDirective": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "Detects comments to enable/disable RuboCop. This is useful if want to make sure that every RuboCop error gets fixed and not quickly disabled with a comment."
        },
        "Style/Documentation": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles",
              "description": "Default: spec//, test//"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for missing top-level documentation of classes and modules. Classes with no body are exempt from the check and so are namespace modules - modules that have nothing in their bodies except classes, other modules, constant definitions or constant visibility declarations.\n\nThe documentation requirement is annulled if the class or module has a \"#:nodoc:\" comment next to it. Likewise, \"#:nodoc: all\" does the same for all its children."
        },
        "Style/DocumentationMethod": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles",
              "description": "Default: spec//, test//"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "RequireForNonPublicMethods": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for missing documentation comment for public methods. It can optionally be configured to also require documentation for non-public methods."
        },
        "Style/DoubleCopDisableDirective": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "Detects double disable comments on one line. This is mostly to catch automatically generated comments that need to be regenerated."
        },
        "Style/DoubleNegation": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "EnforcedStyle": {
              "enum": [
                "allowed_in_returns",
                "forbidden"
              ],
              "description": "Default: allowed_in_returns"
            },
            "SafeAutoCorrect": {
              "type": "boolean",
              "description": "Default: false"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: allowed_in_returns, forbidden"
            }
          },
          "description": "This cop checks for uses of double negation (`!!`) to convert something to a boolean value.\n\nWhen using `EnforcedStyle: allowed_in_returns`, allow double nagation in contexts that use boolean as a return value. When using `EnforcedStyle: forbidden`, double nagation should be forbidden always.\n\nPlease, note that when something is a boolean value !!something and !something.nil? are not the same thing. As you're unlikely to write code that can accept values of any type this is rarely a problem in practice."
        },
        "Style/EachForSimpleLoop": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for loops which iterate a constant number of times, using a Range literal and `#each`. This can be done more readably using `Integer#times`.\n\nThis check only applies if the block takes no parameters."
        },
        "Style/EachWithObject": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop looks for inject / reduce calls where the passed in object is returned at the end and so could be replaced by each_with_object without the need to return the object at the end.\n\nHowever, we can't replace with each_with_object if the accumulator parameter is assigned to within the block."
        },
        "Style/EmptyBlockParameter": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for pipes for empty block parameters. Pipes for empty block parameters do not cause syntax errors, but they are redundant."
        },
        "Style/EmptyCaseCondition": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for case statements with an empty condition."
        },
        "Style/EmptyElse": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "empty",
                "nil",
                "both"
              ],
              "description": "Default: both"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: empty, nil, both"
            }
          },
          "description": "Checks for empty else-clauses, possibly including comments and/or an explicit `nil` depending on the EnforcedStyle."
        },
        "Style/EmptyLambdaParameter": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for parentheses for empty lambda parameters. Parentheses for empty lambda parameters do not cause syntax errors, but they are redundant."
        },
        "Style/EmptyLiteral": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for the use of a method, the result of which would be a literal, like an empty array, hash, or string."
        },
        "Style/EmptyMethod": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "compact",
                "expanded"
              ],
              "description": "Default: compact"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: compact, expanded"
            }
          },
          "description": "This cop checks for the formatting of empty method definitions. By default it enforces empty method definitions to go on a single line (compact style), but it can be configured to enforce the `end` to go on its own line (expanded style).\n\nA method definition is not considered empty if it contains       comments."
        },
        "Style/Encoding": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks ensures source files have no utf-8 encoding comments."
        },
        "Style/EndBlock": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for END blocks."
        },
        "Style/EvalWithLocation": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks `eval` method usage. `eval` can receive source location metadata, that are filename and line number. The metadata is used by backtraces. This cop recommends to pass the metadata to `eval` method."
        },
        "Style/EvenOdd": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for places where `Integer#even?` or `Integer#odd?` can be used."
        },
        "Style/ExpandPathArguments": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for use of the `File.expand_path` arguments. Likewise, it also checks for the `Pathname.new` argument.\n\nContrastive bad case and good case are alternately shown in the following examples."
        },
        "Style/ExplicitBlockArgument": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop enforces the use of explicit block argument to avoid writing block literal that just passes its arguments to another block."
        },
        "Style/ExponentialNotation": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "EnforcedStyle": {
              "enum": [
                "scientific",
                "engineering",
                "integral"
              ],
              "description": "Default: scientific"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: scientific, engineering, integral"
            }
          },
          "description": "This cop enforces consistency when using exponential notation for numbers in the code (eg 1.2e4). Different styles are supported: * `scientific` which enforces a mantissa between 1 (inclusive)                and 10 (exclusive). * `engineering` which enforces the exponent to be a multiple of 3                 and the mantissa to be between 0.1 (inclusive)                 and 10 (exclusive). * `integral` which enforces the mantissa to always be a whole number              without trailing zeroes."
        },
        "Style/FloatDivision": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "EnforcedStyle": {
              "enum": [
                "left_coerce",
                "right_coerce",
                "single_coerce",
                "fdiv"
              ],
              "description": "Default: single_coerce"
            },
            "Reference": {
              "type": "string",
              "description": "Default: https://github.com/rubocop-hq/ruby-style-guide/issues/628"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: left_coerce, right_coerce, single_coerce, fdiv"
            }
          },
          "description": "This cop checks for division with integers coerced to floats. It is recommended to either always use `fdiv` or coerce one side only. This cop also provides other options for code consistency."
        },
        "Style/For": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "each",
                "for"
              ],
              "description": "Default: each"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: each, for"
            }
          },
          "description": "This cop looks for uses of the `for` keyword or `each` method. The preferred alternative is set in the EnforcedStyle configuration parameter. An `each` call with a block on a single line is always allowed."
        },
        "Style/FormatString": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "format",
                "sprintf",
                "percent"
              ],
              "description": "Default: format"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: format, sprintf, percent"
            }
          },
          "description": "This cop enforces the use of a single string formatting utility. Valid options include Kernel#format, Kernel#sprintf and String#%.\n\nThe detection of String#% cannot be implemented in a reliable manner for all cases, so only two scenarios are considered - if the first argument is a string literal and if the second argument is an array literal."
        },
        "Style/FormatStringToken": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "EnforcedStyle": {
              "enum": [
                "annotated",
                "template",
                "unannotated"
              ],
              "description": "Default: annotated"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: annotated, template, unannotated"
            }
          },
          "description": "Use a consistent style for named format string tokens.\n\n`unannotated` style cop only works for strings which are passed as arguments to those methods: `printf`, `sprintf`, `format`, `%`. The reason is that _unannotated_ format is very similar to encoded URLs or Date/Time formatting strings."
        },
        "Style/FrozenStringLiteralComment": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "EnforcedStyle": {
              "enum": [
                "always",
                "always_true",
                "never"
              ],
              "description": "Default: always"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: always, always_true, never"
            },
            "SafeAutoCorrect": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop is designed to help you transition from mutable string literals to frozen string literals. It will add the comment `# frozen_string_literal: true` to the top of files to enable frozen string literals. Frozen string literals may be default in future Ruby. The comment will be added below a shebang and encoding comment.\n\nNote that the cop will ignore files where the comment exists but is set to `false` instead of `true`."
        },
        "Style/GlobalStdStream": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "SafeAutoCorrect": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop enforces the use of `$stdout/$stderr/$stdin` instead of `STDOUT/STDERR/STDIN`. `STDOUT/STDERR/STDIN` are constants, and while you can actually reassign (possibly to redirect some stream) constants in Ruby, you'll get an interpreter warning if you do so."
        },
        "Style/GlobalVars": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AllowedVariables": {
              "type": "array",
              "description": "Default: []"
            },
            "Reference": {
              "type": "string",
              "description": "Default: https://www.zenspider.com/ruby/quickref.html"
            }
          },
          "description": "This cop looks for uses of global variables. It does not report offenses for built-in global variables. Built-in global variables are allowed by default. Additionally users can allow additional variables via the AllowedVariables option.\n\nNote that backreferences like $1, $2, etc are not global variables."
        },
        "Style/GuardClause": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "MinBodyLength": {
              "type": "integer",
              "description": "Default: 1"
            }
          },
          "description": "Use a guard clause instead of wrapping the code inside a conditional expression"
        },
        "Style/HashAsLastArrayItem": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "braces",
                "no_braces"
              ],
              "description": "Default: braces"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: braces, no_braces"
            }
          },
          "description": "Checks for presence or absence of braces around hash literal as a last array item depending on configuration.\n\nThis cop will ignore arrays where all items are hashes, regardless of EnforcedStyle."
        },
        "Style/HashEachMethods": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for uses of `each_key` and `each_value` Hash methods.\n\nIf you have an array of two-element arrays, you can put   parentheses around the block arguments to indicate that you're not   working with a hash, and suppress RuboCop offenses."
        },
        "Style/HashLikeCase": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "MinBranchesCount": {
              "type": "integer",
              "description": "Default: 3"
            }
          },
          "description": "This cop checks for places where `case-when` represents a simple 1:1 mapping and can be replaced with a hash lookup."
        },
        "Style/HashSyntax": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "ruby19",
                "hash_rockets",
                "no_mixed_keys",
                "ruby19_no_mixed_keys"
              ],
              "description": "Default: ruby19"
            },
            "UseHashRocketsWithSymbolValues": {
              "type": "boolean",
              "description": "Default: false"
            },
            "PreferHashRocketsForNonAlnumEndingSymbols": {
              "type": "boolean",
              "description": "Default: false"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: ruby19, hash_rockets, no_mixed_keys, ruby19_no_mixed_keys"
            }
          },
          "description": "This cop checks hash literal syntax.\n\nIt can enforce either the use of the class hash rocket syntax or the use of the newer Ruby 1.9 syntax (when applicable).\n\nA separate offense is registered for each problematic pair.\n\nThe supported styles are:\n\n - ruby19 - forces use of the 1.9 syntax (e.g. {a: 1}) when hashes have\nall symbols for keys\n\n - hash_rockets - forces use of hash rockets for all hashes\n\n - no_mixed_keys - simply checks for hashes with mixed syntaxes\n\n - ruby19_no_mixed_keys - forces use of ruby 1.9 syntax and forbids mixed\nsyntax hashes"
        },
        "Style/HashTransformKeys": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop looks for uses of `_.each_with_object({}) {...}`, `_.map {...}.to_h`, and `Hash[_.map {...}]` that are actually just transforming the keys of a hash, and tries to use a simpler & faster call to `transform_keys` instead.\n\nThis can produce false positives if we are transforming an enumerable of key-value-like pairs that isn't actually a hash, e.g.: `[[k1, v1], [k2, v2], ...]`\n\nThis cop should only be enabled on Ruby version 2.5 or newer (`transform_keys` was added in Ruby 2.5.)"
        },
        "Style/HashTransformValues": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop looks for uses of `_.each_with_object({}) {...}`, `_.map {...}.to_h`, and `Hash[_.map {...}]` that are actually just transforming the values of a hash, and tries to use a simpler & faster call to `transform_values` instead.\n\nThis can produce false positives if we are transforming an enumerable of key-value-like pairs that isn't actually a hash, e.g.: `[[k1, v1], [k2, v2], ...]`\n\nThis cop should only be enabled on Ruby version 2.4 or newer (`transform_values` was added in Ruby 2.4.)"
        },
        "Style/IdenticalConditionalBranches": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for identical lines at the beginning or end of each branch of a conditional statement."
        },
        "Style/IfInsideElse": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AllowIfModifier": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "If the `else` branch of a conditional consists solely of an `if` node, it can be combined with the `else` to become an `elsif`. This helps to keep the nesting level from getting too deep."
        },
        "Style/IfUnlessModifier": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "Checks for `if` and `unless` statements that would fit on one line if written as modifier `if`/`unless`. The cop also checks for modifier `if`/`unless` lines that exceed the maximum line length.\n\nThe maximum line length is configured in the `Layout/LineLength` cop. The tab size is configured in the `IndentationWidth` of the `Layout/IndentationStyle` cop."
        },
        "Style/IfUnlessModifierOfIfUnless": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "Checks for if and unless statements used as modifiers of other if or unless statements."
        },
        "Style/IfWithSemicolon": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "Checks for uses of semicolon in if statements."
        },
        "Style/ImplicitRuntimeError": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for `raise` or `fail` statements which do not specify an explicit exception class. (This raises a `RuntimeError`. Some projects might prefer to use exception classes which more precisely identify the nature of the error.)"
        },
        "Style/InfiniteLoop": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "SafeAutoCorrect": {
              "type": "boolean",
              "description": "Default: true"
            }
          },
          "description": "Use `Kernel#loop` for infinite loops."
        },
        "Style/InlineComment": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for trailing inline comments."
        },
        "Style/InverseMethods": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "InverseMethods": {
              "description": "Default: {:any?⇒:none?, :even?⇒:odd?, :==⇒:!=, :=⇒:!, :<⇒:>=, :>⇒:⇐}"
            },
            "InverseBlocks": {
              "description": "Default: {:select⇒:reject, :select!⇒:reject!}"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop check for usages of not (`not` or `!`) called on a method when an inverse of that method can be used instead. Methods that can be inverted by a not (`not` or `!`) should be defined in `InverseMethods` Methods that are inverted by inverting the return of the block that is passed to the method should be defined in `InverseBlocks`"
        },
        "Style/IpAddresses": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles",
              "description": "Default: /.gemfile, /Gemfile, /gems.rb, /.gemspec"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AllowedAddresses": {
              "type": "array",
              "description": "Default: ::"
            }
          },
          "description": "This cop checks for hardcoded IP addresses, which can make code brittle. IP addresses are likely to need to be changed when code is deployed to a different server or environment, which may break a deployment if forgotten. Prefer setting IP addresses in ENV or other configuration."
        },
        "Style/KeywordParametersOrder": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop enforces that optional keyword parameters are placed at the end of the parameters list.\n\nThis improves readability, because when looking through the source, it is expected to find required parameters at the beginning of parameters list and optional parameters at the end."
        },
        "Style/Lambda": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "line_count_dependent",
                "lambda",
                "literal"
              ],
              "description": "Default: line_count_dependent"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: line_count_dependent, lambda, literal"
            }
          },
          "description": "This cop (by default) checks for uses of the lambda literal syntax for single line lambdas, and the method call syntax for multiline lambdas. It is configurable to enforce one of the styles for both single line and multiline lambdas as well."
        },
        "Style/LambdaCall": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "call",
                "braces"
              ],
              "description": "Default: call"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: call, braces"
            }
          },
          "description": "This cop checks for use of the lambda.(args) syntax."
        },
        "Style/LineEndConcatenation": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "SafeAutoCorrect": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for string literal concatenation at the end of a line."
        },
        "Style/MethodCallWithArgsParentheses": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "IgnoreMacros": {
              "type": "boolean",
              "description": "Default: true"
            },
            "IgnoredMethods": {
              "type": "array",
              "description": "Default: []"
            },
            "IgnoredPatterns": {
              "type": "array",
              "description": "Default: []"
            },
            "IncludedMacros": {
              "type": "array",
              "description": "Default: []"
            },
            "AllowParenthesesInMultilineCall": {
              "type": "boolean",
              "description": "Default: false"
            },
            "AllowParenthesesInChaining": {
              "type": "boolean",
              "description": "Default: false"
            },
            "AllowParenthesesInCamelCaseMethod": {
              "type": "boolean",
              "description": "Default: false"
            },
            "EnforcedStyle": {
              "enum": [
                "require_parentheses",
                "omit_parentheses"
              ],
              "description": "Default: require_parentheses"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: require_parentheses, omit_parentheses"
            }
          },
          "description": "This cop enforces the presence (default) or absence of parentheses in method calls containing parameters.\n\nIn the default style (require_parentheses), macro methods are ignored. Additional methods can be added to the `IgnoredMethods` or `IgnoredPatterns` list. These options are valid only in the default style. Macros can be included by either setting `IgnoreMacros` to false or adding specific macros to the `IncludedMacros` list.\n\nPrecedence of options is all follows:\n\n  1. IgnoredMethods\n\n  2. IgnoredPatterns\n\n  3. IncludedMacros\n\neg. If a method is listed in both `IncludedMacros` and `IgnoredMethods`, then the latter takes precedence (that is, the method is ignored).\n\nIn the alternative style (omit_parentheses), there are three additional options.\n\n  1. AllowParenthesesInChaining is false by default. Setting it to\ntrue allows the presence of parentheses in the last call during\nmethod chaining.\n\n  2. AllowParenthesesInMultilineCall is false by default. Setting it\nto true allows the presence of parentheses in multi-line method\ncalls.\n\n  3. AllowParenthesesInCamelCaseMethod is false by default. This\nallows the presence of parentheses when calling a method whose name\nbegins with a capital letter and which has no arguments. Setting it\nto true allows the presence of parentheses in such a method call\neven with arguments."
        },
        "Style/MethodCallWithoutArgsParentheses": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "IgnoredMethods": {
              "type": "array",
              "description": "Default: []"
            }
          },
          "description": "This cop checks for unwanted parentheses in parameterless method calls."
        },
        "Style/MethodCalledOnDoEndBlock": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for methods called on a do...end block. The point of this check is that it's easy to miss the call tacked on to the block when reading code."
        },
        "Style/MethodDefParentheses": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "require_parentheses",
                "require_no_parentheses",
                "require_no_parentheses_except_multiline"
              ],
              "description": "Default: require_parentheses"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: require_parentheses, require_no_parentheses, require_no_parentheses_except_multiline"
            }
          },
          "description": "This cop checks for parentheses around the arguments in method definitions. Both instance and class/singleton methods are checked."
        },
        "Style/MinMax": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for potential uses of `Enumerable#minmax`."
        },
        "Style/MissingElse": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "EnforcedStyle": {
              "enum": [
                "if",
                "case",
                "both"
              ],
              "description": "Default: both"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: if, case, both"
            }
          },
          "description": "Checks for `if` expressions that do not have an `else` branch.\n\nSupported styles are: if, case, both."
        },
        "Style/MissingRespondToMissing": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for the presence of `method_missing` without also defining `respond_to_missing?`."
        },
        "Style/MixinGrouping": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "separated",
                "grouped"
              ],
              "description": "Default: separated"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: separated, grouped"
            }
          },
          "description": "This cop checks for grouping of mixins in `class` and `module` bodies. By default it enforces mixins to be placed in separate declarations, but it can be configured to enforce grouping them in one declaration."
        },
        "Style/MixinUsage": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks that `include`, `extend` and `prepend` statements appear inside classes and modules, not at the top level, so as to not affect the behavior of `Object`."
        },
        "Style/ModuleFunction": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "EnforcedStyle": {
              "enum": [
                "module_function",
                "extend_self",
                "forbidden"
              ],
              "description": "Default: module_function"
            },
            "Autocorrect": {
              "type": "boolean",
              "description": "Default: false"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: module_function, extend_self, forbidden"
            },
            "SafeAutoCorrect": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for use of `extend self` or `module_function` in a module.\n\nSupported styles are: module_function, extend_self, forbidden.\n\nIn case there are private methods, the cop won't be activated. Otherwise, it forces to change the flow of the default code.\n\nThe option `forbidden` prohibits the usage of both styles.\n\nThese offenses are not safe to auto-correct since there are different implications to each approach."
        },
        "Style/MultilineBlockChain": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for chaining of a block after another block that spans multiple lines."
        },
        "Style/MultilineIfModifier": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "Checks for uses of if/unless modifiers with multiple-lines bodies."
        },
        "Style/MultilineIfThen": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "Checks for uses of the `then` keyword in multi-line if statements."
        },
        "Style/MultilineMemoization": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "keyword",
                "braces"
              ],
              "description": "Default: keyword"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: keyword, braces"
            }
          },
          "description": "This cop checks expressions wrapping styles for multiline memoization."
        },
        "Style/MultilineMethodSignature": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for method signatures that span multiple lines."
        },
        "Style/MultilineTernaryOperator": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for multi-line ternary op expressions.\n\n`return if ... else ... end` is syntax error. If `return` is used before multiline ternary operator expression, it cannot be auto-corrected."
        },
        "Style/MultilineWhenThen": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks uses of the `then` keyword in multi-line when statements."
        },
        "Style/MultipleComparison": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks against comparing a variable with multiple items, where `Array#include?` could be used instead to avoid code repetition."
        },
        "Style/MutableConstant": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "literals",
                "strict"
              ],
              "description": "Default: literals"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: literals, strict"
            }
          },
          "description": "This cop checks whether some constant value isn't a mutable literal (e.g. array or hash).\n\nStrict mode can be used to freeze all constants, rather than just literals. Strict mode is considered an experimental feature. It has not been updated with an exhaustive list of all methods that will produce frozen objects so there is a decent chance of getting some false positives. Luckily, there is no harm in freezing an already frozen object."
        },
        "Style/NegatedIf": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "both",
                "prefix",
                "postfix"
              ],
              "description": "Default: both"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: both, prefix, postfix"
            }
          },
          "description": "Checks for uses of if with a negated condition. Only ifs without else are considered. There are three different styles:\n\n - both\n\n - prefix\n\n - postfix"
        },
        "Style/NegatedUnless": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "both",
                "prefix",
                "postfix"
              ],
              "description": "Default: both"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: both, prefix, postfix"
            }
          },
          "description": "Checks for uses of unless with a negated condition. Only unless without else are considered. There are three different styles:\n\n - both\n\n - prefix\n\n - postfix"
        },
        "Style/NegatedWhile": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "Checks for uses of while with a negated condition."
        },
        "Style/NestedModifier": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for nested use of if, unless, while and until in their modifier form."
        },
        "Style/NestedParenthesizedCalls": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "AllowedMethods": {
              "type": "array",
              "description": "Default: be, be_a, be_an, be_between, be_falsey, be_kind_of, be_instance_of, be_truthy, be_within, eq, eql, end_with, include, match, raise_error, respond_to, start_with"
            }
          },
          "description": "This cop checks for unparenthesized method calls in the argument list of a parenthesized method call."
        },
        "Style/NestedTernaryOperator": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for nested ternary op expressions."
        },
        "Style/Next": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "skip_modifier_ifs",
                "always"
              ],
              "description": "Default: skip_modifier_ifs"
            },
            "MinBodyLength": {
              "type": "integer",
              "description": "Default: 3"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: skip_modifier_ifs, always"
            }
          },
          "description": "Use `next` to skip iteration instead of a condition at the end."
        },
        "Style/NilComparison": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "predicate",
                "comparison"
              ],
              "description": "Default: predicate"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: predicate, comparison"
            }
          },
          "description": "This cop checks for comparison of something with nil using `==` and `nil?`.\n\nSupported styles are: predicate, comparison."
        },
        "Style/NonNilCheck": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "IncludeSemanticChanges": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for non-nil checks, which are usually redundant.\n\nWith `IncludeSemanticChanges` set to `false` by default, this cop does not report offenses for `!x.nil?` and does no changes that might change behavior.\n\nWith `IncludeSemanticChanges` set to `true`, this cop reports offenses for `!x.nil?` and autocorrects that and `x != nil` to solely `x`, which is *usually* OK, but might change behavior."
        },
        "Style/Not": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for uses of the keyword `not` instead of `!`."
        },
        "Style/NumericLiteralPrefix": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedOctalStyle": {
              "enum": [
                "zero_with_o",
                "zero_only"
              ],
              "description": "Default: zero_with_o"
            },
            "SupportedOctalStyles": {
              "type": "array",
              "description": "Default: zero_with_o, zero_only"
            }
          },
          "description": "This cop checks for octal, hex, binary, and decimal literals using uppercase prefixes and corrects them to lowercase prefix or no prefix (in case of decimals)."
        },
        "Style/NumericLiterals": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "MinDigits": {
              "type": "integer",
              "description": "Default: 5"
            },
            "Strict": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for big numeric literals without _ between groups of digits in them."
        },
        "Style/NumericPredicate": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles",
              "description": "Default: spec/*/"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "EnforcedStyle": {
              "enum": [
                "predicate",
                "comparison"
              ],
              "description": "Default: predicate"
            },
            "IgnoredMethods": {
              "type": "array",
              "description": "Default: []"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            },
            "SafeAutoCorrect": {
              "type": "boolean",
              "description": "Default: false"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: predicate, comparison"
            }
          },
          "description": "This cop checks for usage of comparison operators (`==`, `>`, `<`) to test numbers as zero, positive, or negative. These can be replaced by their respective predicate methods. The cop can also be configured to do the reverse.\n\nThe cop disregards `#nonzero?` as it its value is truthy or falsey, but not `true` and `false`, and thus not always interchangeable with `!= 0`.\n\nThe cop ignores comparisons to global variables, since they are often populated with objects which can be compared with integers, but are not themselves `Integer` polymorphic."
        },
        "Style/OneLineConditional": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "AlwaysCorrectToMultiline": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "Checks for uses of if/then/else/end constructs on a single line. AlwaysCorrectToMultiline config option can be set to true to auto-convert all offenses to multi-line constructs. When AlwaysCorrectToMultiline is false (default case) the auto-correct will first try converting them to ternary operators."
        },
        "Style/OptionHash": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "SuspiciousParamNames": {
              "type": "array",
              "description": "Default: options, opts, args, params, parameters"
            }
          },
          "description": "This cop checks for options hashes and discourages them if the current Ruby version supports keyword arguments."
        },
        "Style/OptionalArguments": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for optional arguments to methods that do not come at the end of the argument list."
        },
        "Style/OptionalBooleanParameter": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for places where keyword arguments can be used instead of boolean arguments when defining methods."
        },
        "Style/OrAssignment": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for potential usage of the `||=` operator."
        },
        "Style/ParallelAssignment": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "Checks for simple usages of parallel assignment. This will only complain when the number of variables being assigned matched the number of assigning variables."
        },
        "Style/ParenthesesAroundCondition": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "AllowSafeAssignment": {
              "type": "boolean",
              "description": "Default: true"
            },
            "AllowInMultilineConditions": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for the presence of superfluous parentheses around the condition of if/unless/while/until.\n\n`AllowSafeAssignment` option for safe assignment. By safe assignment we mean putting parentheses around an assignment to indicate \"I know I'm using an assignment as a condition. It's not a mistake.\""
        },
        "Style/PercentLiteralDelimiters": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "PreferredDelimiters": {
              "description": "Default: {\"default\"⇒\"()\", \"%i\"⇒\"[]\", \"%I\"⇒\"[]\", \"%r\"⇒\"{}\", \"%w\"⇒\"[]\", \"%W\"⇒\"[]\"}"
            }
          },
          "description": "This cop enforces the consistent usage of `%`-literal delimiters.\n\nSpecify the 'default' key to set all preferred delimiters at once. You can continue to specify individual preferred delimiters to override the default."
        },
        "Style/PercentQLiterals": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "lower_case_q",
                "upper_case_q"
              ],
              "description": "Default: lower_case_q"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: lower_case_q, upper_case_q"
            }
          },
          "description": "This cop checks for usage of the %Q() syntax when %q() would do."
        },
        "Style/PerlBackrefs": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop looks for uses of Perl-style regexp match backreferences like $1, $2, etc."
        },
        "Style/PreferredHashMethods": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "EnforcedStyle": {
              "enum": [
                "short",
                "verbose"
              ],
              "description": "Default: short"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: short, verbose"
            }
          },
          "description": "This cop (by default) checks for uses of methods Hash#has_key? and Hash#has_value? where it enforces Hash#key? and Hash#value? It is configurable to enforce the inverse, using `verbose` method names also."
        },
        "Style/Proc": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for uses of Proc.new where Kernel#proc would be more appropriate."
        },
        "Style/RaiseArgs": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "compact",
                "exploded"
              ],
              "description": "Default: exploded"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: compact, exploded"
            }
          },
          "description": "This cop checks the args passed to `fail` and `raise`. For exploded style (default), it recommends passing the exception class and message to `raise`, rather than construct an instance of the error. It will still allow passing just a message, or the construction of an error with more than one argument.\n\nThe exploded style works identically, but with the addition that it will also suggest constructing error objects when the exception is passed multiple arguments."
        },
        "Style/RandomWithOffset": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for the use of randomly generated numbers, added/subtracted with integer literals, as well as those with Integer#succ and Integer#pred methods. Prefer using ranges instead, as it clearly states the intentions."
        },
        "Style/RedundantAssignment": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for redundant assignment before returning."
        },
        "Style/RedundantBegin": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for redundant `begin` blocks.\n\nCurrently it checks for code like this:"
        },
        "Style/RedundantCapitalW": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for usage of the %W() syntax when %w() would do."
        },
        "Style/RedundantCondition": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for unnecessary conditional expressions."
        },
        "Style/RedundantConditional": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for redundant returning of true/false in conditionals."
        },
        "Style/RedundantException": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for RuntimeError as the argument of raise/fail.\n\nIt checks for code like this:"
        },
        "Style/RedundantFetchBlock": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "SafeForConstants": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Reference": {
              "type": "string",
              "description": "Default: https://github.com/JuanitoFatas/fast-ruby#hashfetch-with-argument-vs-hashfetch--block-code"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop identifies places where `fetch(key) { value }` can be replaced by `fetch(key, value)`.\n\nIn such cases `fetch(key, value)` method is faster than `fetch(key) { value }`."
        },
        "Style/RedundantFileExtensionInRequire": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for the presence of superfluous `.rb` extension in the filename provided to `require` and `require_relative`.\n\nNote: If the extension is omitted, Ruby tries adding '.rb', '.so',       and so on to the name until found. If the file named cannot be found,       a `LoadError` will be raised.       There is an edge case where `foo.so` file is loaded instead of a `LoadError`       if `foo.so` file exists when `require 'foo.rb'` will be changed to `require 'foo'`,       but that seems harmless."
        },
        "Style/RedundantFreeze": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop check for uses of Object#freeze on immutable objects."
        },
        "Style/RedundantInterpolation": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for strings that are just an interpolated expression."
        },
        "Style/RedundantParentheses": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for redundant parentheses."
        },
        "Style/RedundantPercentQ": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for usage of the %q/%Q syntax when '' or \"\" would do."
        },
        "Style/RedundantRegexpCharacterClass": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for unnecessary single-element Regexp character classes."
        },
        "Style/RedundantRegexpEscape": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for redundant escapes inside Regexp literals."
        },
        "Style/RedundantReturn": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "AllowMultipleReturnValues": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for redundant `return` expressions."
        },
        "Style/RedundantSelf": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for redundant uses of `self`.\n\nThe usage of `self` is only needed when:\n\n - Sending a message to same object with zero arguments in\npresence of a method name clash with an argument or a local\nvariable.\n\n - Calling an attribute writer to prevent an local variable assignment.\n\nNote, with using explicit self you can only send messages with public or protected scope, you cannot send private messages this way.\n\nNote we allow uses of `self` with operators because it would be awkward otherwise."
        },
        "Style/RedundantSelfAssignment": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for places where redundant assignments are made for in place modification methods.\n\nThis cop is marked as unsafe, because it can produce false positives for user defined methods having one of the expected names, but not modifying its receiver in place."
        },
        "Style/RedundantSort": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop is used to identify instances of sorting and then taking only the first or last element. The same behavior can be accomplished without a relatively expensive sort by using `Enumerable#min` instead of sorting and taking the first element and `Enumerable#max` instead of sorting and taking the last element. Similarly, `Enumerable#min_by` and `Enumerable#max_by` can replace `Enumerable#sort_by` calls after which only the first or last element is used."
        },
        "Style/RedundantSortBy": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop identifies places where `sort_by { ... }` can be replaced by `sort`."
        },
        "Style/RegexpLiteral": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "slashes",
                "percent_r",
                "mixed"
              ],
              "description": "Default: slashes"
            },
            "AllowInnerSlashes": {
              "type": "boolean",
              "description": "Default: false"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: slashes, percent_r, mixed"
            }
          },
          "description": "This cop enforces using // or %r around regular expressions."
        },
        "Style/RescueModifier": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for uses of rescue in its modifier form.\n\nThe cop to check `rescue` in its modifier form is added for following reasons:\n\n - The syntax of modifier form rescue can be misleading because it\nmight led us to believe that rescue handles the given exception\nbut it actually rescue all exceptions to return the given rescue\nblock. In this case, value returned by handle_error or\nSomeException.\n\n - Modifier form rescue would rescue all the exceptions. It would\nsilently skip all exception or errors and handle the error.\nExample: If NoMethodError is raised, modifier form rescue would\nhandle the exception."
        },
        "Style/RescueStandardError": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "implicit",
                "explicit"
              ],
              "description": "Default: explicit"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: implicit, explicit"
            }
          },
          "description": "This cop checks for rescuing `StandardError`. There are two supported styles `implicit` and `explicit`. This cop will not register an offense if any error other than `StandardError` is specified."
        },
        "Style/ReturnNil": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "return",
                "return_nil"
              ],
              "description": "Default: return"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: return, return_nil"
            }
          },
          "description": "This cop enforces consistency between 'return nil' and 'return'.\n\nSupported styles are: return, return_nil."
        },
        "Style/SafeNavigation": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "ConvertCodeThatCanStartToReturnNil": {
              "type": "boolean",
              "description": "Default: false"
            },
            "AllowedMethods": {
              "type": "array",
              "description": "Default: present?, blank?, presence, try, try!"
            },
            "SafeAutoCorrect": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop transforms usages of a method call safeguarded by a non `nil` check for the variable whose method is being called to safe navigation (`&.`). If there is a method chain, all of the methods in the chain need to be checked for safety, and all of the methods will need to be changed to use safe navigation. We have limited the cop to not register an offense for method chains that exceed 2 methods.\n\nConfiguration option: ConvertCodeThatCanStartToReturnNil The default for this is `false`. When configured to `true`, this will check for code in the format `!foo.nil? && foo.bar`. As it is written, the return of this code is limited to `false` and whatever the return of the method is. If this is converted to safe navigation, `foo&.bar` can start returning `nil` as well as what the method returns."
        },
        "Style/Sample": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "Reference": {
              "type": "string",
              "description": "Default: https://github.com/JuanitoFatas/fast-ruby#arrayshufflefirst-vs-arraysample-code"
            }
          },
          "description": "This cop is used to identify usages of `shuffle.first`, `shuffle.last`, and `shuffle[]` and change them to use `sample` instead."
        },
        "Style/SelfAssignment": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop enforces the use the shorthand for self-assignment."
        },
        "Style/Semicolon": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "AllowAsExpressionSeparator": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for multiple expressions placed on the same line. It also checks for lines terminated with a semicolon.\n\nThis cop has `AllowAsExpressionSeparator` configuration option. It allows `;` to separate several expressions on the same line."
        },
        "Style/Send": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for the use of the send method."
        },
        "Style/SignalException": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "only_raise",
                "only_fail",
                "semantic"
              ],
              "description": "Default: only_raise"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: only_raise, only_fail, semantic"
            }
          },
          "description": "This cop checks for uses of `fail` and `raise`."
        },
        "Style/SingleArgumentDig": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "Sometimes using dig method ends up with just a single argument. In such cases, dig should be replaced with []."
        },
        "Style/SingleLineBlockParams": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "Methods": {
              "type": "array",
              "description": "Default: {\"reduce\"⇒[\"acc\", \"elem\"]}, {\"inject\"⇒[\"acc\", \"elem\"]}"
            }
          },
          "description": "This cop checks whether the block parameters of a single-line method accepting a block match the names specified via configuration.\n\nFor instance one can configure `reduce`(`inject`) to use |a, e| as parameters.\n\nConfiguration option: Methods Should be set to use this cop. Array of hashes, where each key is the method name and value - array of argument names."
        },
        "Style/SingleLineMethods": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "AllowIfMethodIsEmpty": {
              "type": "boolean",
              "description": "Default: true"
            }
          },
          "description": "This cop checks for single-line method definitions that contain a body. It will accept single-line methods with no body."
        },
        "Style/SlicingWithRange": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks that arrays are sliced with endless ranges instead of `ary[start..-1]` on Ruby 2.6+."
        },
        "Style/SoleNestedConditional": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AllowModifier": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "If the branch of a conditional consists solely of a conditional node, its conditions can be combined with the conditions of the outer branch. This helps to keep the nesting level from getting too deep."
        },
        "Style/SpecialGlobalVars": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "EnforcedStyle": {
              "enum": [
                "use_perl_names",
                "use_english_names"
              ],
              "description": "Default: use_english_names"
            },
            "SafeAutoCorrect": {
              "type": "boolean",
              "description": "Default: false"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: use_perl_names, use_english_names"
            }
          },
          "description": "This cop looks for uses of Perl-style global variables."
        },
        "Style/StabbyLambdaParentheses": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "require_parentheses",
                "require_no_parentheses"
              ],
              "description": "Default: require_parentheses"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: require_parentheses, require_no_parentheses"
            }
          },
          "description": "Check for parentheses around stabby lambda arguments. There are two different styles. Defaults to `require_parentheses`."
        },
        "Style/StderrPuts": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop identifies places where `$stderr.puts` can be replaced by `warn`. The latter has the advantage of easily being disabled by, the `-W0` interpreter flag or setting `$VERBOSE` to `nil`."
        },
        "Style/StringConcatenation": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for places where string concatenation can be replaced with string interpolation.\n\nThe cop can autocorrect simple cases but will skip autocorrecting more complex cases where the resulting code would be harder to read. In those cases, it might be useful to extract statements to local variables or methods which you can then interpolate in a string."
        },
        "Style/StringHashKeys": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for the use of strings as keys in hashes. The use of symbols is preferred instead."
        },
        "Style/StringLiterals": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "single_quotes",
                "double_quotes"
              ],
              "description": "Default: single_quotes"
            },
            "ConsistentQuotesInMultiline": {
              "type": "boolean",
              "description": "Default: false"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: single_quotes, double_quotes"
            }
          },
          "description": "Checks if uses of quotes match the configured preference."
        },
        "Style/StringLiteralsInInterpolation": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "single_quotes",
                "double_quotes"
              ],
              "description": "Default: single_quotes"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: single_quotes, double_quotes"
            }
          },
          "description": "This cop checks that quotes inside the string interpolation match the configured preference."
        },
        "Style/StringMethods": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "PreferredMethods": {
              "description": "Default: {\"intern\"⇒\"to_sym\"}"
            }
          },
          "description": "This cop enforces the use of consistent method names from the String class."
        },
        "Style/Strip": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop identifies places where `lstrip.rstrip` can be replaced by `strip`."
        },
        "Style/StructInheritance": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for inheritance from Struct.new."
        },
        "Style/SymbolArray": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "percent",
                "brackets"
              ],
              "description": "Default: percent"
            },
            "MinSize": {
              "type": "integer",
              "description": "Default: 2"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: percent, brackets"
            }
          },
          "description": "This cop can check for array literals made up of symbols that are not using the %i() syntax.\n\nAlternatively, it checks for symbol arrays using the %i() syntax on projects which do not want to use that syntax.\n\nConfiguration option: MinSize If set, arrays with fewer elements than this value will not trigger the cop. For example, a `MinSize` of `3` will not enforce a style on an array of 2 or fewer elements."
        },
        "Style/SymbolLiteral": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks symbol literal syntax."
        },
        "Style/SymbolProc": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "IgnoredMethods": {
              "type": "array",
              "description": "Default: respond_to, define_method"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "Use symbols as procs when possible."
        },
        "Style/TernaryParentheses": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "require_parentheses",
                "require_no_parentheses",
                "require_parentheses_when_complex"
              ],
              "description": "Default: require_no_parentheses"
            },
            "AllowSafeAssignment": {
              "type": "boolean",
              "description": "Default: true"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: require_parentheses, require_no_parentheses, require_parentheses_when_complex"
            }
          },
          "description": "This cop checks for the presence of parentheses around ternary conditions. It is configurable to enforce inclusion or omission of parentheses using `EnforcedStyle`. Omission is only enforced when removing the parentheses won't cause a different behavior.\n\n`AllowSafeAssignment` option for safe assignment. By safe assignment we mean putting parentheses around an assignment to indicate \"I know I'm using an assignment as a condition. It's not a mistake.\""
        },
        "Style/TrailingBodyOnClass": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for trailing code after the class definition."
        },
        "Style/TrailingBodyOnMethodDefinition": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for trailing code after the method definition."
        },
        "Style/TrailingBodyOnModule": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for trailing code after the module definition."
        },
        "Style/TrailingCommaInArguments": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyleForMultiline": {
              "enum": [
                "comma",
                "consistent_comma",
                "no_comma"
              ],
              "description": "Default: no_comma"
            },
            "SupportedStylesForMultiline": {
              "type": "array",
              "description": "Default: comma, consistent_comma, no_comma"
            }
          },
          "description": "This cop checks for trailing comma in argument lists. The supported styles are:\n\n - consistent_comma: Requires a comma after the last argument,\nfor all parenthesized method calls with arguments.\n\n - comma: Requires a comma after the last argument, but only for\nparenthesized method calls where each argument is on its own line.\n\n - no_comma: Requires that there is no comma after the last\nargument."
        },
        "Style/TrailingCommaInArrayLiteral": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyleForMultiline": {
              "enum": [
                "comma",
                "consistent_comma",
                "no_comma"
              ],
              "description": "Default: no_comma"
            },
            "SupportedStylesForMultiline": {
              "type": "array",
              "description": "Default: comma, consistent_comma, no_comma"
            }
          },
          "description": "This cop checks for trailing comma in array literals. The configuration options are:\n\n - consistent_comma: Requires a comma after the\nlast item of all non-empty, multiline array literals.\n\n - comma: Requires a comma after last item in an array,\nbut only when each item is on its own line.\n\n - no_comma: Does not requires a comma after the\nlast item in an array"
        },
        "Style/TrailingCommaInBlockArgs": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks whether trailing commas in block arguments are required. Blocks with only one argument and a trailing comma require that comma to be present. Blocks with more than one argument never require a trailing comma."
        },
        "Style/TrailingCommaInHashLiteral": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyleForMultiline": {
              "enum": [
                "comma",
                "consistent_comma",
                "no_comma"
              ],
              "description": "Default: no_comma"
            },
            "SupportedStylesForMultiline": {
              "type": "array",
              "description": "Default: comma, consistent_comma, no_comma"
            }
          },
          "description": "This cop checks for trailing comma in hash literals. The configuration options are:\n\n - consistent_comma: Requires a comma after the\nlast item of all non-empty, multiline hash literals.\n\n - comma: Requires a comma after the last item in a hash,\nbut only when each item is on its own line.\n\n - no_comma: Does not requires a comma after the\nlast item in a hash"
        },
        "Style/TrailingMethodEndStatement": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for trailing code after the method definition."
        },
        "Style/TrailingUnderscoreVariable": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "AllowNamedUnderscoreVariables": {
              "type": "boolean",
              "description": "Default: true"
            }
          },
          "description": "This cop checks for extra underscores in variable assignment."
        },
        "Style/TrivialAccessors": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "ExactNameMatch": {
              "type": "boolean",
              "description": "Default: true"
            },
            "AllowPredicates": {
              "type": "boolean",
              "description": "Default: true"
            },
            "AllowDSLWriters": {
              "type": "boolean",
              "description": "Default: false"
            },
            "IgnoreClassMethods": {
              "type": "boolean",
              "description": "Default: false"
            },
            "AllowedMethods": {
              "type": "array",
              "description": "Default: to_ary, to_a, to_c, to_enum, to_h, to_hash, to_i, to_int, to_io, to_open, to_path, to_proc, to_r, to_regexp, to_str, to_s, to_sym"
            }
          },
          "description": "This cop looks for trivial reader/writer methods, that could have been created with the attr_* family of functions automatically."
        },
        "Style/UnlessElse": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop looks for `unless` expressions with `else` clauses."
        },
        "Style/UnpackFirst": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for accessing the first element of `String#unpack` which can be replaced with the shorter method `unpack1`."
        },
        "Style/VariableInterpolation": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for variable interpolation (like \"#@ivar\")."
        },
        "Style/WhenThen": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for `when;` uses in `case` expressions."
        },
        "Style/WhileUntilDo": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "Checks for uses of `do` in multi-line `while/until` statements."
        },
        "Style/WhileUntilModifier": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "Checks for while and until statements that would fit on one line if written as a modifier while/until. The maximum line length is configured in the `Layout/LineLength` cop."
        },
        "Style/WordArray": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "percent",
                "brackets"
              ],
              "description": "Default: percent"
            },
            "MinSize": {
              "type": "integer",
              "description": "Default: 2"
            },
            "WordRegex": {
              "enum": [
                "\\p{Word}-\\p{Word}"
              ],
              "description": "Default: `(?-mix:\\A(?:\\p{Word}"
            },
            "\\n": {
              "description": "Default: \\t)+\\z)`"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: percent, brackets"
            }
          },
          "description": "This cop can check for array literals made up of word-like strings, that are not using the %w() syntax.\n\nAlternatively, it can check for uses of the %w() syntax, in projects which do not want to include that syntax.\n\nConfiguration option: MinSize If set, arrays with fewer elements than this value will not trigger the cop. For example, a `MinSize` of `3` will not enforce a style on an array of 2 or fewer elements."
        },
        "Style/YodaCondition": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "EnforcedStyle": {
              "enum": [
                "forbid_for_all_comparison_operators",
                "forbid_for_equality_operators_only",
                "require_for_all_comparison_operators",
                "require_for_equality_operators_only"
              ],
              "description": "Default: forbid_for_all_comparison_operators"
            },
            "Reference": {
              "type": "string",
              "description": "Default: https://en.wikipedia.org/wiki/Yoda_conditions"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: forbid_for_all_comparison_operators, forbid_for_equality_operators_only, require_for_all_comparison_operators, require_for_equality_operators_only"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop can either enforce or forbid Yoda conditions, i.e. comparison operations where the order of expression is reversed. eg. `5 == x`"
        },
        "Style/ZeroLengthPredicate": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: true"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for numeric comparisons that can be replaced by a predicate method, such as receiver.length == 0, receiver.length > 0, receiver.length != 0, receiver.length < 1 and receiver.size == 0 that can be replaced by receiver.empty? and !receiver.empty?."
        }
      }
    }
  },
  {
    "version": "0.92.0",
    "diff": {
      "properties": {
        "Style/ArrayCoercion": {
          "properties": {
            "Enabled": {
              "description": "Default: false"
            }
          },
          "description": "This cop enforces the use of `Array()` instead of explicit `Array` check or `[*var]`.\n\nThis cop is disabled by default because false positive will occur if the argument of `Array()` is not an array (e.g. Hash, Set), an array will be returned as an incompatibility result."
        },
        "Style/DateTime": {
          "properties": {
            "SafeAutoCorrect": {
              "type": "boolean",
              "description": "Default: false"
            }
          }
        },
        "Style/OptionalBooleanParameter": {
          "properties": {
            "AllowedMethods": {
              "type": "array",
              "description": "Default: respond_to_missing?"
            }
          },
          "description": "This cop checks for places where keyword arguments can be used instead of boolean arguments when defining methods. `respond_to_missing?` method is allowed by default. These are customizable with `AllowedMethods` option."
        }
      }
    }
  },
  {
    "version": "0.93.0",
    "diff": {
      "properties": {
        "Lint/HashCompareByIdentity": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "Prefer using `Hash#compare_by_identity` than using `object_id` for hash keys.\n\nThis cop is marked as unsafe as a hash possibly can contain other keys besides `object_id`s."
        },
        "Lint/RedundantSafeNavigation": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "IgnoredMethods": {
              "type": "array",
              "description": "Default: to_c, to_f, to_i, to_r, rationalize, public_send, send, send"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for redundant safe navigation calls. It is marked as unsafe, because it can produce code that returns non `nil` while `nil` result is expected on `nil` receiver."
        },
        "Metrics/BlockLength": {
          "description": "This cop checks if the length of a block exceeds some maximum value. Comment lines can optionally be ignored. The maximum allowed length is configurable. The cop can be configured to ignore blocks passed to certain methods.\n\nYou can set literals you want to fold with `CountAsOne`. Available are: 'array', 'hash', and 'heredoc'. Each literal will be counted as one line regardless of its actual size.\n\nThis cop does not apply for `Struct` definitions."
        },
        "Metrics/ClassLength": {
          "description": "This cop checks if the length a class exceeds some maximum value. Comment lines can optionally be ignored. The maximum allowed length is configurable.\n\nYou can set literals you want to fold with `CountAsOne`. Available are: 'array', 'hash', and 'heredoc'. Each literal will be counted as one line regardless of its actual size.\n\nThis cop also applies for `Struct` definitions."
        },
        "Style/AccessorGrouping": {
          "description": "This cop checks for grouping of accessors in `class` and `module` bodies. By default it enforces accessors to be placed in grouped declarations, but it can be configured to enforce separating them in multiple declarations.\n\nNote: `Sorbet` is not compatible with \"grouped\" style. Consider \"separated\" style or disabling this cop."
        },
        "Style/ClassEqualityComparison": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "IgnoredMethods": {
              "type": "array",
              "description": "Default: ==, equal?, eql?"
            }
          },
          "description": "This cop enforces the use of `Object#instance_of?` instead of class comparison for equality."
        },
        "Style/CommentAnnotation": {
          "description": "This cop checks that comment annotation keywords are written according to guidelines.\n\nWith a multiline comment block (where each line is only a comment), only the first line will be able to register an offense, even if an annotation keyword starts another line. This is done to prevent incorrect registering of keywords (eg. `review`) inside a paragraph as an annotation."
        }
      }
    }
  },
  {
    "version": "0.93.1",
    "diff": {
      "properties": {
        "Lint/RedundantSafeNavigation": {
          "properties": {
            "IgnoredMethods": null,
            "AllowedMethods": {
              "type": "array",
              "description": "Default: instance_of?, kind_of?, is_a?, eql?, respond_to?, equal?"
            }
          },
          "description": "This cop checks for redundant safe navigation calls. `instance_of?`, `kind_of?`, `is_a?`, `eql?`, `respond_to?`, and `equal?` methods are checked by default. These are customizable with `AllowedMethods` option.\n\nThis cop is marked as unsafe, because auto-correction can change the return type of the expression. An offending expression that previously could return `nil` will be auto-corrected to never return `nil`.\n\nIn the example below, the safe navigation operator (`&.`) is unnecessary because `NilClass` has methods like `respond_to?` and `is_a?`."
        }
      }
    }
  },
  {
    "version": "1.0.0",
    "diff": {
      "properties": {
        "Layout/BeginEndAlignment": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Layout/EmptyLinesAroundAttributeAccessor": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Layout/SpaceAroundMethodCallOperator": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Layout/SpaceAroundOperators": {
          "description": "Checks that operators have space around them, except for ** which should or shouldn't have surrounding space depending on configuration. It allows vertical alignment consisting of one or more whitespace around operators.\n\nThis cop has `AllowForAlignment` option. When `true`, allows most uses of extra spacing if the intent is to align with an operator on the previous or next line, not counting empty lines or comment lines."
        },
        "Layout/TrailingWhitespace": {
          "properties": {
            "AllowInHeredoc": {
              "description": "Default: false"
            }
          }
        },
        "Lint/BinaryOperatorWithIdenticalOperands": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Lint/ConstantDefinitionInBlock": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Lint/DeprecatedOpenSSLConstant": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Lint/DuplicateElsifCondition": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Lint/DuplicateRequire": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Lint/DuplicateRescueException": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Lint/EmptyConditionalBody": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Lint/EmptyFile": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Lint/FloatComparison": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Lint/HashCompareByIdentity": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Lint/IdentityComparison": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Lint/MissingSuper": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Lint/MixedRegexpCaptureTypes": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Lint/OutOfRangeRegexpRef": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Lint/RaiseException": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Lint/RedundantSafeNavigation": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Lint/SelfAssignment": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Lint/StructNewOverride": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Lint/TopLevelReturnWithArgument": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Lint/TrailingCommaInAttributeDeclaration": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Lint/UnreachableLoop": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Lint/UselessMethodDefinition": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Lint/UselessTimes": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Security/Open": {
          "description": "This cop checks for the use of `Kernel#open` and `URI.open`.\n\n`Kernel#open` and `URI.open` enable not only file access but also process invocation by prefixing a pipe symbol (e.g., `open(\"| ls\")`). So, it may lead to a serious security risk by using variable input to the argument of `Kernel#open` and `URI.open`. It would be better to use `File.open`, `IO.popen` or `URI.parse#open` explicitly."
        },
        "Style/AccessorGrouping": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          },
          "description": "This cop checks for grouping of accessors in `class` and `module` bodies. By default it enforces accessors to be placed in grouped declarations, but it can be configured to enforce separating them in multiple declarations.\n\n`Sorbet` is not compatible with \"grouped\" style. Consider \"separated\" style or disabling this cop."
        },
        "Style/BisectedAttrAccessor": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Style/CaseLikeIf": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Style/ClassEqualityComparison": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Style/CombinableLoops": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Style/ExplicitBlockArgument": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Style/ExponentialNotation": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Style/FormatStringToken": {
          "properties": {
            "MaxUnannotatedPlaceholdersAllowed": {
              "type": "integer",
              "description": "Default: 1"
            }
          },
          "description": "Use a consistent style for named format string tokens.\n\n`unannotated` style cop only works for strings which are passed as arguments to those methods: `printf`, `sprintf`, `format`, `%`. The reason is that _unannotated_ format is very similar to encoded URLs or Date/Time formatting strings.\n\nIt is allowed to contain unannotated token if the number of them is less than or equals to `MaxUnannotatedPlaceholdersAllowed`."
        },
        "Style/GlobalStdStream": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Style/HashAsLastArrayItem": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Style/HashEachMethods": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Style/HashLikeCase": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Style/HashTransformKeys": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Style/HashTransformValues": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Style/KeywordParametersOrder": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Style/OptionalBooleanParameter": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Style/RedundantAssignment": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Style/RedundantFetchBlock": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Style/RedundantFileExtensionInRequire": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Style/RedundantRegexpCharacterClass": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Style/RedundantRegexpEscape": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Style/RedundantSelfAssignment": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Style/SingleArgumentDig": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Style/SlicingWithRange": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Style/SoleNestedConditional": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        },
        "Style/StringConcatenation": {
          "properties": {
            "Enabled": {
              "description": "Default: true"
            }
          }
        }
      }
    }
  },
  {
    "version": "1.1.0",
    "diff": {
      "properties": {
        "Lint/DuplicateRegexpCharacterClassElement": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for duplicate elements in Regexp character classes."
        },
        "Lint/EmptyBlock": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AllowComments": {
              "type": "boolean",
              "description": "Default: true"
            }
          },
          "description": "This cop checks for blocks without a body. Such empty blocks are typically an oversight or we should provide a comment be clearer what we're aiming for."
        },
        "Lint/FlipFlop": {
          "description": "This cop looks for uses of flip-flop operator based on the Ruby Style Guide.\n\nHere is the history of flip-flops in Ruby. flip-flop operator is deprecated in Ruby 2.6.0 and the deprecation has been reverted by Ruby 2.7.0 and backported to Ruby 2.6. See: https://bugs.ruby-lang.org/issues/5400"
        },
        "Lint/MultipleComparison": {
          "properties": {
            "AllowMethodComparison": {
              "type": "boolean",
              "description": "Default: true"
            }
          }
        },
        "Lint/NumberConversion": {
          "properties": {
            "IgnoredMethods": {
              "type": "array",
              "description": "Default: []"
            },
            "IgnoredClasses": {
              "type": "array",
              "description": "Default: Time, DateTime"
            }
          },
          "description": "This cop warns the usage of unsafe number conversions. Unsafe number conversion can cause unexpected error if auto type conversion fails. Cop prefer parsing with number class instead.\n\nConversion with `Integer`, `Float`, etc. will raise an `ArgumentError` if given input that is not numeric (eg. an empty string), whereas `to_i`, etc. will try to convert regardless of input (`''.to_i => 0`). As such, this cop is disabled by default because it's not necessarily always correct to raise if a value is not numeric.\n\nSome values cannot be converted properly using one of the `Kernel` method (for instance, `Time` and `DateTime` values are allowed by this cop by default). Similarly, Rails' duration methods do not work well with `Integer()` and can be ignored with `IgnoredMethods`."
        },
        "Lint/ToEnumArguments": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop ensures that `to_enum`/`enum_for`, called for the current method, has correct arguments."
        },
        "Lint/UnmodifiedReduceAccumulator": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "Looks for `reduce` or `inject` blocks where the value returned (implicitly or explicitly) does not include the accumulator. A block is considered valid as long as at least one return value includes the accumulator.\n\nIf the accumulator is not included in the return value, then the entire block will just return a transformation of the last element value, and could be rewritten as such without a loop.\n\nAlso catches instances where an index of the accumulator is returned, as this may change the type of object being retained.\n\nFor the purpose of reducing false positives, this cop only flags returns in `reduce` blocks where the element is the only variable in the expression (since we will not be able to tell what other variables relate to via static analysis)."
        },
        "Style/ArgumentsForwarding": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "AllowOnlyRestArgument": {
              "type": "boolean",
              "description": "Default: true"
            }
          },
          "description": "In Ruby 2.7, arguments forwarding has been added.\n\nThis cop identifies places where `do_something(*args, &block)` can be replaced by `do_something(...)`."
        },
        "Style/DocumentDynamicEvalDefinition": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "When using `class_eval` (or other `eval`) with string interpolation, add a comment block showing its appearance if interpolated (a practice used in Rails code)."
        },
        "Style/MultipleComparison": {
          "properties": {
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks against comparing a variable with multiple items, where `Array#include?`, `Set#include?` or a `case` could be used instead to avoid code repetition. It accepts comparisons of multiple method calls to avoid unnecessary method calls by default. It can be configured by `AllowMethodComparison` option."
        },
        "Style/SwapValues": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "SafeAutoCorrect": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop enforces the use of shorthand-style swapping of 2 variables. Its autocorrection is marked as unsafe, because it can erroneously remove the temporary variable which is used later."
        }
      }
    }
  },
  {
    "version": "1.2.0",
    "diff": {
      "properties": {
        "Layout/ElseAlignment": {
          "description": "This cop checks the alignment of else keywords. Normally they should be aligned with an if/unless/while/until/begin/def/rescue keyword, but there are special cases when they should follow the same rules as the alignment of end."
        },
        "Lint/ElseLayout": {
          "properties": {
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for odd `else` block layout - like having an expression on the same line as the `else` keyword, which is usually a mistake.\n\nIts auto-correction tweaks layout to keep the syntax. So, this auto-correction is compatible correction for bad case syntax, but if your code makes a mistake with `elsif` and `else`, you will have to correct it manually."
        },
        "Lint/NoReturnInBeginEndBlocks": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "Checks for the presence of a `return` inside a `begin..end` block in assignment contexts. In this situation, the `return` will result in an exit from the current method, possibly leading to unexpected behavior."
        },
        "Lint/UselessSetterCall": {
          "properties": {
            "SafeAutoCorrect": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for setter call to local variable as the final expression of a function definition. Its auto-correction is marked as unsafe because return value will be changed.\n\nThere are edge cases in which the local variable references a value that is also accessible outside the local scope. This is not detected by the cop, and it can yield a false positive."
        },
        "Naming/BinaryOperatorParameterName": {
          "properties": {
            "AutoCorrect": {
              "type": "boolean"
            }
          }
        },
        "Naming/HeredocDelimiterCase": {
          "properties": {
            "AutoCorrect": {
              "type": "boolean"
            }
          }
        },
        "Naming/VariableNumber": {
          "properties": {
            "CheckMethodNames": {
              "type": "boolean",
              "description": "Default: true"
            },
            "CheckSymbols": {
              "type": "boolean",
              "description": "Default: true"
            }
          },
          "description": "This cop makes sure that all numbered variables use the configured style, snake_case, normalcase, or non_integer, for their numbering.\n\nAdditionally, `CheckMethodNames` and `CheckSymbols` configuration options can be used to specify whether method names and symbols should be checked. Both are enabled by default."
        },
        "Style/CollectionCompact": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for places where custom logic on rejection nils from arrays and hashes can be replaced with `{Array,Hash}#{compact,compact!}`."
        },
        "Style/NegatedIfElseCondition": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for uses of `if-else` and ternary operators with a negated condition which can be simplified by inverting condition and swapping branches."
        },
        "Style/RaiseArgs": {
          "properties": {
            "AllowedCompactTypes": {
              "type": "array",
              "description": "Default: []"
            }
          },
          "description": "This cop checks the args passed to `fail` and `raise`. For exploded style (default), it recommends passing the exception class and message to `raise`, rather than construct an instance of the error. It will still allow passing just a message, or the construction of an error with more than one argument.\n\nThe exploded style works identically, but with the addition that it will also suggest constructing error objects when the exception is passed multiple arguments.\n\nThe exploded style has an `AllowedCompactTypes` configuration option that takes an Array of exception name Strings."
        }
      }
    }
  },
  {
    "version": "1.3.0",
    "diff": {
      "properties": {
        "Lint/ConstantDefinitionInBlock": {
          "properties": {
            "AllowedMethods": {
              "type": "array",
              "description": "Default: []"
            }
          }
        },
        "Lint/Debugger": {
          "properties": {
            "DebuggerReceivers": {
              "type": "array",
              "description": "Default: binding, Kernel, Pry"
            },
            "DebuggerMethods": {
              "type": "array",
              "description": "Default: debugger, byebug, remote_byebug, pry, remote_pry, pry_remote, console, rescue, save_and_open_page, save_and_open_screenshot, irb"
            }
          },
          "description": "This cop checks for calls to debugger or pry. The cop can be configured to define which methods and receivers must be fixed."
        },
        "Lint/DuplicateBranch": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks that there are no repeated bodies within `if/unless`, `case-when` and `rescue` constructs."
        },
        "Lint/EmptyBlock": {
          "properties": {
            "AllowEmptyLambdas": {
              "type": "boolean",
              "description": "Default: true"
            }
          },
          "description": "This cop checks for blocks without a body. Such empty blocks are typically an oversight or we should provide a comment be clearer what we're aiming for.\n\nEmpty lambdas are ignored by default."
        },
        "Lint/EmptyClass": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AllowComments": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for classes and metaclasses without a body. Such empty classes and metaclasses are typically an oversight or we should provide a comment to be clearer what we're aiming for."
        },
        "Lint/Loop": {
          "properties": {
            "AutoCorrect": null,
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for uses of `begin...end while/until something`.\n\nThe cop is marked as unsafe because behaviour can change in some cases, including if a local variable inside the loop body is accessed outside of it, or if the loop body raises a `StopIteration` exception (which `Kernel#loop` rescues)."
        },
        "Naming/VariableNumber": {
          "properties": {
            "AllowedIdentifiers": {
              "type": "array",
              "description": "Default: []"
            }
          }
        },
        "Style/CollectionCompact": {
          "properties": {
            "AutoCorrect": null,
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for places where custom logic on rejection nils from arrays and hashes can be replaced with `{Array,Hash}#{compact,compact!}`.\n\nIt is marked as unsafe by default because false positives may occur in the nil check of block arguments to the receiver object. For example, `[[1, 2], [3, nil]].reject { |first, second| second.nil? }` and `[[1, 2], [3, nil]].compact` are not compatible. This will work fine when the receiver is a hash object."
        },
        "Style/CommentAnnotation": {
          "properties": {
            "Keywords": {
              "description": "Default: TODO, FIXME, OPTIMIZE, HACK, REVIEW, NOTE"
            }
          }
        },
        "Style/IdenticalConditionalBranches": {
          "description": "This cop checks for identical expressions at the beginning or end of each branch of a conditional expression. Such expressions should normally be placed outside the conditional expression - before or after it.\n\nThe cop is poorly named and some people might think that it actually checks for duplicated conditional branches. The name will probably be changed in a future major RuboCop release."
        },
        "Style/IfInsideElse": {
          "properties": {
            "AutoCorrect": {
              "type": "boolean"
            }
          }
        },
        "Style/InfiniteLoop": {
          "properties": {
            "AutoCorrect": null,
            "SafeAutoCorrect": null,
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "Use `Kernel#loop` for infinite loops.\n\nThis cop is marked as unsafe as the rule does not necessarily apply if the body might raise a `StopIteration` exception; contrary to other infinite loops, `Kernel#loop` silently rescues that and returns `nil`."
        },
        "Style/NilLambda": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for lambdas that always return nil, which can be replaced with an empty lambda instead."
        },
        "Style/StaticClass": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for places where classes with only class methods can be replaced with a module. Classes should be used only when it makes sense to create instances out of them.\n\nThis cop is marked as unsafe, because it is possible that this class is a parent for some other subclass, monkey-patched with instance methods or a dummy instance is instantiated from it somewhere."
        }
      }
    }
  },
  {
    "version": "1.3.1",
    "diff": {
      "properties": {
        "Lint/ConstantDefinitionInBlock": {
          "properties": {
            "AllowedMethods": {
              "description": "Default: enums"
            }
          }
        }
      }
    }
  },
  {
    "version": "1.4.0",
    "diff": {
      "properties": {
        "Layout/EmptyLineBetweenDefs": {
          "properties": {
            "EmptyLineBetweenMethodDefs": {
              "type": "boolean",
              "description": "Default: true"
            },
            "EmptyLineBetweenClassDefs": {
              "type": "boolean",
              "description": "Default: true"
            },
            "EmptyLineBetweenModuleDefs": {
              "type": "boolean",
              "description": "Default: true"
            }
          }
        },
        "Layout/LineLength": {
          "properties": {
            "AutoCorrect": {
              "description": "Default: true"
            }
          }
        },
        "Lint/MissingSuper": {
          "description": "This cop checks for the presence of constructors and lifecycle callbacks without calls to `super`.\n\nThis cop does not consider `method_missing` (and `respond_to_missing?`) because in some cases it makes sense to overtake what is considered a missing method. In other cases, the theoretical ideal handling could be challenging or verbose for no actual gain."
        },
        "Style/RedundantArgument": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "Methods": {
              "description": "Default: {\"join\"⇒\"\", \"split\"⇒\" \"}"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for a redundant argument passed to certain methods.\n\nLimitations:\n\n  1. This cop matches for method names only and hence cannot tell apart\nmethods with same name in different classes.\n\n  2. This cop is limited to methods with single parameter.\n\n  3. This cop is unsafe if certain special global variables (e.g. $;) are set.\nThat depends on the nature of the target methods, of course.\n\nMethod names and their redundant arguments can be configured like this:\n\nMethods:   join: ''   split: ' '   foo: 2"
        }
      }
    }
  },
  {
    "version": "1.4.1",
    "diff": {
    }
  },
  {
    "version": "1.4.2",
    "diff": {
      "properties": {
        "Layout/EmptyLineBetweenDefs": {
          "description": "This cop checks whether class/module/method definitions are separated by one or more empty lines.\n\n`NumberOfEmptyLines` can be an integer (default is 1) or an array (e.g. [1, 2]) to specify a minimum and maximum number of empty lines permitted.\n\n`AllowAdjacentOneLineDefs` configures whether adjacent one-line definitions are considered an offense."
        },
        "Lint/UnmodifiedReduceAccumulator": {
          "description": "Looks for `reduce` or `inject` blocks where the value returned (implicitly or explicitly) does not include the accumulator. A block is considered valid as long as at least one return value includes the accumulator.\n\nIf the accumulator is not included in the return value, then the entire block will just return a transformation of the last element value, and could be rewritten as such without a loop.\n\nAlso catches instances where an index of the accumulator is returned, as this may change the type of object being retained. As well, detects when fewer than 2 block arguments are specified.\n\nFor the purpose of reducing false positives, this cop only flags returns in `reduce` blocks where the element is the only variable in the expression (since we will not be able to tell what other variables relate to via static analysis)."
        }
      }
    }
  },
  {
    "version": "1.5.0",
    "diff": {
      "properties": {
        "AllCops": {
          "properties": {
            "SuggestExtensions": {
              "description": "Default: {\"rubocop-rails\"=>[\"rails\"], \"rubocop-rspec\"=>[\"rspec\", \"rspec-rails\"], \"rubocop-minitest\"=>[\"minitest\"], \"rubocop-sequel\"=>[\"sequel\"], \"rubocop-rake\"=>[\"rake\"]}"
            }
          }
        },
        "Lint/UnexpectedBlockArity": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "Methods": {
              "description": "Default: {\"chunk_while\"⇒2, \"each_with_index\"⇒2, \"each_with_object\"⇒2, \"inject\"⇒2, \"max\"⇒2, \"min\"⇒2, \"minmax\"⇒2, \"reduce\"⇒2, \"slice_when\"⇒2, \"sort\"⇒2}"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for a block that is known to need more positional block arguments than are given (by default this is configured for `Enumerable` methods needing 2 arguments). Optional arguments are allowed, although they don't generally make sense as the default value will be used. Blocks that have no receiver, or take splatted arguments (ie. `*args`) are always accepted.\n\nKeyword arguments (including `**kwargs`) do not get counted towards this, as they are not used by the methods in question.\n\nThis cop matches for method names only and hence cannot tell apart methods with same name in different classes.\n\nMethod names and their expected arity can be configured like this:\n\nMethods:   inject: 2   reduce: 2"
        },
        "Lint/UnmodifiedReduceAccumulator": {
          "description": "Looks for `reduce` or `inject` blocks where the value returned (implicitly or explicitly) does not include the accumulator. A block is considered valid as long as at least one return value includes the accumulator.\n\nIf the accumulator is not included in the return value, then the entire block will just return a transformation of the last element value, and could be rewritten as such without a loop.\n\nAlso catches instances where an index of the accumulator is returned, as this may change the type of object being retained.\n\nFor the purpose of reducing false positives, this cop only flags returns in `reduce` blocks where the element is the only variable in the expression (since we will not be able to tell what other variables relate to via static analysis)."
        },
        "Metrics/AbcSize": {
          "properties": {
            "CountRepeatedAttributes": {
              "type": "boolean",
              "description": "Default: true"
            }
          },
          "description": "This cop checks that the ABC size of methods is not higher than the configured maximum. The ABC size is based on assignments, branches (method calls), and conditions. See http://c2.com/cgi/wiki?AbcMetric and https://en.wikipedia.org/wiki/ABC_Software_Metric.\n\nYou can have repeated \"attributes\" calls count as a single \"branch\". For this purpose, attributes are any method with no argument; no attempt is meant to distinguish actual `attr_reader` from other methods.\n\nThis cop also takes into account `IgnoredMethods` (defaults to `[]`)"
        },
        "Metrics/BlockLength": {
          "properties": {
            "ExcludedMethods": {
              "description": "Default: []"
            },
            "IgnoredMethods": {
              "type": "array",
              "description": "Default: refine"
            }
          },
          "description": "This cop checks if the length of a block exceeds some maximum value. Comment lines can optionally be ignored. The maximum allowed length is configurable. The cop can be configured to ignore blocks passed to certain methods.\n\nYou can set literals you want to fold with `CountAsOne`. Available are: 'array', 'hash', and 'heredoc'. Each literal will be counted as one line regardless of its actual size.\n\nThe `ExcludedMethods` configuration is deprecated and only kept for backwards compatibility. Please use `IgnoredMethods` instead.\n\nThis cop does not apply for `Struct` definitions."
        },
        "Metrics/MethodLength": {
          "properties": {
            "IgnoredMethods": {
              "type": "array",
              "description": "Default: []"
            }
          },
          "description": "This cop checks if the length of a method exceeds some maximum value. Comment lines can optionally be ignored. The maximum allowed length is configurable.\n\nYou can set literals you want to fold with `CountAsOne`. Available are: 'array', 'hash', and 'heredoc'. Each literal will be counted as one line regardless of its actual size.\n\nThe `ExcludedMethods` configuration is deprecated and only kept for backwards compatibility. Please use `IgnoredMethods` instead."
        },
        "Metrics/ParameterLists": {
          "properties": {
            "MaxOptionalParameters": {
              "type": "integer",
              "description": "Default: 3"
            }
          },
          "description": "This cop checks for methods with too many parameters.\n\nThe maximum number of parameters is configurable. Keyword arguments can optionally be excluded from the total count, as they add less complexity than positional or optional parameters.\n\nThis cop also checks for the maximum number of optional parameters. This can be configured using the `MaxOptionalParameters` config option."
        },
        "Naming/VariableNumber": {
          "properties": {
            "AllowedIdentifiers": {
              "description": "Default: capture3, iso8601, rfc1123_date, rfc822, rfc2822, rfc3339"
            }
          }
        },
        "Style/SoleNestedConditional": {
          "properties": {
            "AutoCorrect": {
              "type": "boolean"
            }
          }
        }
      }
    }
  },
  {
    "version": "1.5.1",
    "diff": {
    }
  },
  {
    "version": "1.5.2",
    "diff": {
      "properties": {
        "Lint/ShadowingOuterLocalVariable": {
          "description": "This cop checks for the use of local variable names from an outer scope in block arguments or block-local variables. This mirrors the warning given by `ruby -cw` prior to Ruby 2.6: \"shadowing outer local variable - foo\".\n\nShadowing of variables in block passed to `Ractor.new` is allowed because `Ractor` should not access outer variables. eg. following syle is encouraged:\n\n  worker_id, pipe = env\n  Ractor.new(worker_id, pipe) do |worker_id, pipe|\n  end"
        }
      }
    }
  },
  {
    "version": "1.6.0",
    "diff": {
      "properties": {
        "Naming/AccessorMethodName": {
          "description": "This cop makes sure that accessor methods are named properly. Applies to both instance and class methods.\n\nOffenses are only registered for methods with the expected arity. Getters (`get_attribute`) must have no arguments to be registered, and setters (`set_attribute(value)`) must have exactly one."
        },
        "Style/FloatDivision": {
          "properties": {
            "AutoCorrect": {
              "type": "boolean"
            },
            "Reference": {
              "description": "Default: https://blog.rubystyle.guide/ruby/2019/06/21/float-division.html"
            }
          }
        },
        "Style/PerlBackrefs": {
          "description": "This cop looks for uses of Perl-style regexp match backreferences and their English versions like $1, $2, $&, &+, $MATCH, $PREMATCH, etc."
        },
        "Style/SingleLineBlockParams": {
          "properties": {
            "AutoCorrect": {
              "type": "boolean"
            }
          }
        },
        "Style/StringConcatenation": {
          "description": "This cop checks for places where string concatenation can be replaced with string interpolation.\n\nThe cop can autocorrect simple cases but will skip autocorrecting more complex cases where the resulting code would be harder to read. In those cases, it might be useful to extract statements to local variables or methods which you can then interpolate in a string.\n\nWhen concatenation between two strings is broken over multiple lines, this cop does not register an offense; instead, `Style/LineEndConcatenation` will pick up the offense if enabled."
        }
      }
    }
  },
  {
    "version": "1.6.1",
    "diff": {
    }
  },
  {
    "version": "1.7.0",
    "diff": {
      "properties": {
        "Layout/SpaceBeforeBrackets": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "Checks for space between the name of a receiver and a left brackets.\n\nThis cop is marked as unsafe because it can occur false positives for `do_something [this_is_an_array_literal_argument]` that take an array without parentheses as an argument."
        },
        "Lint/AmbiguousAssignment": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for mistyped shorthand assignments."
        },
        "Lint/DuplicateBranch": {
          "properties": {
            "IgnoreLiteralBranches": {
              "type": "boolean",
              "description": "Default: false"
            },
            "IgnoreConstantBranches": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks that there are no repeated bodies within `if/unless`, `case-when` and `rescue` constructs.\n\nWith `IgnoreLiteralBranches: true`, branches are not registered as offenses if they return a basic literal value (string, symbol, integer, float, rational, complex, `true`, `false`, or `nil`), or return an array, hash, regexp or range that only contains one of the above basic literal values.\n\nWith `IgnoreConstantBranches: true`, branches are not registered as offenses if they return a constant value."
        },
        "Lint/RedundantSplatExpansion": {
          "properties": {
            "AllowPercentLiteralArrayArgument": {
              "type": "boolean",
              "description": "Default: true"
            }
          }
        },
        "Lint/UnreachableLoop": {
          "properties": {
            "IgnoredPatterns": {
              "enum": [
                "at_least"
              ],
              "description": "Default: `(?-mix:(exactly"
            }
          },
          "description": "This cop checks for loops that will have at most one iteration.\n\nA loop that can never reach the second iteration is a possible error in the code. In rare cases where only one iteration (or at most one iteration) is intended behavior, the code should be refactored to use `if` conditionals.\n\nBlock methods that are used with `Enumerable`s are considered to be loops.\n\n`IgnoredPatterns` can be used to match against the block receiver in order to allow code that would otherwise be registered as an offense (eg. `times` used not in an `Enumerable` context)."
        },
        "Naming/MemoizedInstanceVariableName": {
          "description": "This cop checks for memoized methods whose instance variable name does not match the method name. Applies to both regular methods (defined with `def`) and dynamic methods (defined with `define_method` or `define_singleton_method`).\n\nThis cop can be configured with the EnforcedStyleForLeadingUnderscores directive. It can be configured to allow for memoized instance variables prefixed with an underscore. Prefixing ivars with an underscore is a convention that is used to implicitly indicate that an ivar should not be set or referenced outside of the memoization method."
        },
        "Style/CollectionMethods": {
          "properties": {
            "MethodsAcceptingSymbol": {
              "type": "array",
              "description": "Default: inject, reduce"
            }
          }
        },
        "Style/CommentedKeyword": {
          "properties": {
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for comments put on the same line as some keywords. These keywords are: `class`, `module`, `def`, `begin`, `end`.\n\nNote that some comments (`:nodoc:`, `:yields:`, `rubocop:disable` and `rubocop:todo`) are allowed.\n\nAuto-correction removes comments from `end` keyword and keeps comments for `class`, `module`, `def` and `begin` above the keyword."
        },
        "Style/HashExcept": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for usages of `Hash#reject`, `Hash#select`, and `Hash#filter` methods that can be replaced with `Hash#except` method.\n\nThis cop should only be enabled on Ruby version 3.0 or higher. (`Hash#except` was added in Ruby 3.0.)\n\nFor safe detection, it is limited to commonly used string and symbol comparisons when used `==`. And do not check `Hash#delete_if` and `Hash#keep_if` to change receiver object."
        },
        "Style/MethodCallWithArgsParentheses": {
          "description": "This cop enforces the presence (default) or absence of parentheses in method calls containing parameters.\n\nIn the default style (require_parentheses), macro methods are ignored. Additional methods can be added to the `IgnoredMethods` or `IgnoredPatterns` list. These options are valid only in the default style. Macros can be included by either setting `IgnoreMacros` to false or adding specific macros to the `IncludedMacros` list.\n\nPrecedence of options is all follows:\n\n  1. IgnoredMethods\n\n  2. IgnoredPatterns\n\n  3. IncludedMacros\n\neg. If a method is listed in both `IncludedMacros` and `IgnoredMethods`, then the latter takes precedence (that is, the method is ignored).\n\nIn the alternative style (omit_parentheses), there are three additional options.\n\n  1. AllowParenthesesInChaining is false by default. Setting it to\ntrue allows the presence of parentheses in the last call during\nmethod chaining.\n\n  2. AllowParenthesesInMultilineCall is false by default. Setting it\nto true allows the presence of parentheses in multi-line method\ncalls.\n\n  3. AllowParenthesesInCamelCaseMethod is false by default. This\nallows the presence of parentheses when calling a method whose name\nbegins with a capital letter and which has no arguments. Setting it\nto true allows the presence of parentheses in such a method call\neven with arguments.\n\nParens are required around a method with arguments when inside an endless method definition (>= Ruby 3.0)."
        },
        "Style/MethodDefParentheses": {
          "description": "This cop checks for parentheses around the arguments in method definitions. Both instance and class/singleton methods are checked.\n\nThis cop does not consider endless methods, since parentheses are always required for them."
        },
        "Style/MultilineMethodSignature": {
          "properties": {
            "AutoCorrect": {
              "type": "boolean"
            }
          }
        },
        "Style/MutableConstant": {
          "description": "This cop checks whether some constant value isn't a mutable literal (e.g. array or hash).\n\nStrict mode can be used to freeze all constants, rather than just literals. Strict mode is considered an experimental feature. It has not been updated with an exhaustive list of all methods that will produce frozen objects so there is a decent chance of getting some false positives. Luckily, there is no harm in freezing an already frozen object.\n\nRegexp and Range literals are frozen objects since Ruby 3.0."
        },
        "Style/RedundantArgument": {
          "properties": {
            "Methods": {
              "description": "Default: {\"join\"⇒\"\", \"split\"⇒\" \", \"chomp\"⇒\"\\n\", \"chomp!\"⇒\"\\n\"}"
            }
          },
          "description": "This cop checks for a redundant argument passed to certain methods.\n\nLimitations:\n\n  1. This cop matches for method names only and hence cannot tell apart\nmethods with same name in different classes.\n\n  2. This cop is limited to methods with single parameter.\n\n  3. This cop is unsafe if certain special global variables (e.g. $;, $/) are set.\nThat depends on the nature of the target methods, of course.\n\nMethod names and their redundant arguments can be configured like this:\n\nMethods:   join: ''   split: ' '   chomp: \"\\n\"   chomp!: \"\\n\"   foo: 2"
        },
        "Style/RedundantFreeze": {
          "description": "This cop check for uses of `Object#freeze` on immutable objects.\n\nRegexp and Range literals are frozen objects since Ruby 3.0."
        },
        "Style/SingleLineMethods": {
          "description": "This cop checks for single-line method definitions that contain a body. It will accept single-line methods with no body.\n\nEndless methods added in Ruby 3.0 are also accepted by this cop."
        }
      }
    }
  },
  {
    "version": "1.8.0",
    "diff": {
      "properties": {
        "Layout/SpaceBeforeBrackets": {
          "properties": {
            "Safe": null,
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "Checks for space between the name of a receiver and a left brackets."
        },
        "Lint/DeprecatedConstants": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "DeprecatedConstants": {
              "description": "Default: {\"NIL\"⇒{\"Alternative\"⇒\"nil\", \"DeprecatedVersion\"⇒\"2.4\"}, \"TRUE\"⇒{\"Alternative\"⇒\"true\", \"DeprecatedVersion\"⇒\"2.4\"}, \"FALSE\"⇒{\"Alternative\"⇒\"false\", \"DeprecatedVersion\"⇒\"2.4\"}, \"Random::DEFAULT\"⇒{\"Alternative\"⇒\"Random.new\", \"DeprecatedVersion\"⇒\"3.0\"}}"
            }
          },
          "description": "This cop checks for deprecated constants.\n\nIt has `DeprecatedConstants` config. If there is an alternative method, you can set alternative value as `Alternative`. And you can set the deprecated version as `DeprecatedVersion`. These options can be omitted if they are not needed.\n\n  DeprecatedConstants:\n    'DEPRECATED_CONSTANT':\n      Alternative: 'alternative_value'\n      DeprecatedVersion: 'deprecated_version'\n\nBy default, `NIL`, `TRUE`, `FALSE` and `Random::DEFAULT` are configured."
        },
        "Lint/LambdaWithoutLiteralBlock": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks uses of lambda without a literal block. It emulates the following warning in Ruby 3.0:\n\n  % ruby -vwe 'lambda(&proc {})'\n  ruby 3.0.0p0 (2020-12-25 revision 95aff21468) [x86_64-darwin19]\n  -e:1: warning: lambda without a literal block is deprecated; use the proc without\n  lambda instead\n\nThis way, proc object is never converted to lambda. Auto-correction replaces with compatible proc argument."
        },
        "Lint/NonDeterministicRequireOrder": {
          "description": "`Dir[...]` and `Dir.glob(...)` do not make any guarantees about the order in which files are returned. The final order is determined by the operating system and file system. This means that using them in cases where the order matters, such as requiring files, can lead to intermittent failures that are hard to debug. To ensure this doesn't happen, always sort the list.\n\n`Dir.glob` and `Dir[]` sort globbed results by default in Ruby 3.0. So all bad cases are acceptable when Ruby 3.0 or higher are used.\n\nThis cop will be deprecated and removed when supporting only Ruby 3.0 and higher."
        },
        "Lint/RedundantDirGlobSort": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "Sort globbed results by default in Ruby 3.0. This cop checks for redundant `sort` method to `Dir.glob` and `Dir[]`."
        },
        "Naming/VariableName": {
          "properties": {
            "AllowedIdentifiers": {
              "type": "array",
              "description": "Default: []"
            }
          }
        },
        "Style/EndlessMethod": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "allow_single_line",
                "allow_always",
                "disallow"
              ],
              "description": "Default: allow_single_line"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: allow_single_line, allow_always, disallow"
            }
          },
          "description": "This cop checks for endless methods.\n\nIt can enforce either the use of endless methods definitions for single-lined method bodies, or disallow endless methods.\n\nOther method definition types are not considered by this cop.\n\nThe supported styles are: * allow_single_line (default) - only single line endless method definitions are allowed. * allow_always - all endless method definitions are allowed. * disallow - all endless method definitions are disallowed.\n\nIncorrect endless method definitions will always be corrected to a multi-line definition."
        },
        "Style/MutableConstant": {
          "properties": {
            "AutoCorrect": null,
            "SafeAutoCorrect": {
              "type": "boolean",
              "description": "Default: false"
            }
          }
        },
        "Style/SingleLineMethods": {
          "description": "This cop checks for single-line method definitions that contain a body. It will accept single-line methods with no body.\n\nEndless methods added in Ruby 3.0 are also accepted by this cop.\n\nIf `Style/EndlessMethod` is enabled with `EnforcedStyle: allow` or `allow_always`, single-line methods will be auto-corrected to endless methods if there is only one statement in the body."
        }
      }
    }
  },
  {
    "version": "1.8.1",
    "diff": {
      "properties": {
        "Style/ExplicitBlockArgument": {
          "properties": {
            "Safe": null,
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop enforces the use of explicit block argument to avoid writing block literal that just passes its arguments to another block.\n\nThis cop only registers an offense if the block args match the yield args exactly."
        }
      }
    }
  },
  {
    "version": "1.9.0",
    "diff": {
      "properties": {
        "Lint/NumberedParameterAssignment": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for uses of numbered parameter assignment. It emulates the following warning in Ruby 2.7:\n\n  % ruby -ve '_1 = :value'\n  ruby 2.7.2p137 (2020-10-01 revision 5445e04352) [x86_64-darwin19]\n  -e:1: warning: `_1' is reserved for numbered parameter; consider another name\n\nAssiging to numbered parameter (from `_1` to `_9`) cause an error in Ruby 3.0.\n\n  % ruby -ve '_1 = :value'\n  ruby 3.0.0p0 (2020-12-25 revision 95aff21468) [x86_64-darwin19]\n  -e:1: _1 is reserved for numbered parameter\n\nThe parametered parameters are from `_1` to `_9`. This cop checks `_0`, and over `_10` as well to prevent confusion."
        },
        "Lint/OrAssignmentToConstant": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for unintended or-assignment to a constant.\n\nConstants should always be assigned in the same location. And its value should always be the same. If constants are assigned in multiple locations, the result may vary depending on the order of `require`.\n\nAlso, if you already have such an implementation, auto-correction may change the result."
        },
        "Lint/SymbolConversion": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for uses of literal strings converted to a symbol where a literal symbol could be used instead."
        },
        "Lint/TripleQuotes": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for \"triple quotes\" (strings delimted by any odd number of quotes greater than 1).\n\nRuby allows multiple strings to be implicitly concatenated by just being adjacent in a statement (ie. `\"foo\"\"bar\" == \"foobar\"`). This sometimes gives the impression that there is something special about triple quotes, but in fact it is just extra unnecessary quotes and produces the same string. Each pair of quotes produces an additional concatenated empty string, so the result is still only the \"actual\" string within the delimiters.\n\nAlthough this cop is called triple quotes, the same behavior is present for strings delimited by 5, 7, etc. quotation marks."
        },
        "Style/AsciiComments": {
          "properties": {
            "AllowedChars": {
              "description": "Default: ©"
            }
          },
          "description": "This cop checks for non-ascii (non-English) characters in comments. You could set an array of allowed non-ascii chars in `AllowedChars` attribute (copyright notice \"©\" by default)."
        },
        "Style/DisableCopsWithinSourceCodeDirective": {
          "properties": {
            "AllowedCops": {
              "type": "array",
              "description": "Default: []"
            }
          },
          "description": "Detects comments to enable/disable RuboCop. This is useful if want to make sure that every RuboCop error gets fixed and not quickly disabled with a comment.\n\nSpecific cops can be allowed with the `AllowedCops` configuration. Note that if this configuration is set, `rubocop:disable all` is still disallowed."
        },
        "Style/EvalWithLocation": {
          "description": "This cop ensures that eval methods (`eval`, `instance_eval`, `class_eval` and `module_eval`) are given filename and line number values (`__FILE__` and `__LINE__`). This data is used to ensure that any errors raised within the evaluated code will be given the correct identification in a backtrace.\n\nThe cop also checks that the line number given relative to `__LINE__` is correct."
        },
        "Style/FloatDivision": {
          "properties": {
            "AutoCorrect": null,
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for division with integers coerced to floats. It is recommended to either always use `fdiv` or coerce one side only. This cop also provides other options for code consistency.\n\nThis cop is marked as unsafe, because if operand variable is a string object then `.to_f` will be removed and an error will occur."
        },
        "Style/FormatStringToken": {
          "properties": {
            "IgnoredMethods": {
              "type": "array",
              "description": "Default: []"
            }
          },
          "description": "Use a consistent style for named format string tokens.\n\n`unannotated` style cop only works for strings which are passed as arguments to those methods: `printf`, `sprintf`, `format`, `%`. The reason is that _unannotated_ format is very similar to encoded URLs or Date/Time formatting strings.\n\nThis cop can be customized ignored methods with `IgnoredMethods`.\n\nIt is allowed to contain unannotated token if the number of them is less than or equals to `MaxUnannotatedPlaceholdersAllowed`."
        },
        "Style/IfWithBooleanLiteralBranches": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for redundant `if` with boolean literal branches. It checks only conditions to return boolean value (`true` or `false`) for safe detection. The conditions to be checked are comparison methods, predicate methods, and double negative."
        },
        "Style/NonNilCheck": {
          "description": "This cop checks for non-nil checks, which are usually redundant.\n\nWith `IncludeSemanticChanges` set to `false` by default, this cop does not report offenses for `!x.nil?` and does no changes that might change behavior. Also `IncludeSemanticChanges` set to `false` with `EnforcedStyle: comparison` of `Style/NilComparison` cop, this cop does not report offenses for `x != nil` and does no changes to `!x.nil?` style.\n\nWith `IncludeSemanticChanges` set to `true`, this cop reports offenses for `!x.nil?` and autocorrects that and `x != nil` to solely `x`, which is *usually* OK, but might change behavior."
        },
        "Style/SingleLineMethods": {
          "description": "This cop checks for single-line method definitions that contain a body. It will accept single-line methods with no body.\n\nEndless methods added in Ruby 3.0 are also accepted by this cop.\n\nIf `Style/EndlessMethod` is enabled with `EnforcedStyle: allow_single_line` or `allow_always`, single-line methods will be auto-corrected to endless methods if there is only one statement in the body."
        }
      }
    }
  },
  {
    "version": "1.9.1",
    "diff": {
      "properties": {
        "Layout/FirstArgumentIndentation": {
          "description": "This cop checks the indentation of the first argument in a method call. Arguments after the first one are checked by `Layout/ArgumentAlignment`, not by this cop.\n\nFor indenting the first parameter of method _definitions_, check out `Layout/FirstParameterIndentation`.\n\nThis cop will respect `Layout/ArgumentAlignment` and will not work when `EnforcedStyle: with_fixed_indentation` is specified for `Layout/ArgumentAlignment`."
        },
        "Style/IfWithBooleanLiteralBranches": {
          "properties": {
            "AutoCorrect": null,
            "AllowedMethods": {
              "type": "array",
              "description": "Default: nonzero?"
            },
            "SafeAutoCorrect": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for redundant `if` with boolean literal branches. It checks only conditions to return boolean value (`true` or `false`) for safe detection. The conditions to be checked are comparison methods, predicate methods, and double negative. However, auto-correction is unsafe because there is no guarantee that all predicate methods will return boolean value. Those methods can be allowed with `AllowedMethods` config."
        },
        "Style/NumericPredicate": {
          "description": "This cop checks for usage of comparison operators (`==`, `>`, `<`) to test numbers as zero, positive, or negative. These can be replaced by their respective predicate methods. The cop can also be configured to do the reverse.\n\nThe cop disregards `#nonzero?` as its value is truthy or falsey, but not `true` and `false`, and thus not always interchangeable with `!= 0`.\n\nThe cop ignores comparisons to global variables, since they are often populated with objects which can be compared with integers, but are not themselves `Integer` polymorphic."
        }
      }
    }
  },
  {
    "version": "1.10.0",
    "diff": {
      "properties": {
        "Gemspec/DateAssignment": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles",
              "description": "Default: **/*.gemspec"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks that `date =` is not used in gemspec file. It is set automatically when the gem is packaged."
        },
        "Lint/Debugger": {
          "properties": {
            "DebuggerReceivers": {
              "description": "Default: []"
            },
            "DebuggerMethods": {
              "type": null,
              "description": "Default: {\"Kernel\"⇒[\"binding.irb\"], \"Byebug\"⇒[\"byebug\", \"remote_byebug\", \"Kernel.byebug\", \"Kernel.remote_byebug\"], \"Capybara\"⇒[\"save_and_open_page\", \"save_and_open_screenshot\"], \"Pry\"⇒[\"binding.pry\", \"binding.remote_pry\", \"binding.pry_remote\", \"Pry.rescue\"], \"Rails\"⇒[\"debugger\", \"Kernel.debugger\"], \"WebConsole\"⇒[\"binding.console\"]}"
            }
          },
          "description": "This cop checks for debug calls (such as `debugger` or `binding.pry`) that should not be kept for production code.\n\nThe cop can be configured using `DebuggerMethods`. By default, a number of gems debug entrypoints are configured (`Kernel`, `Byebug`, `Capybara`, `Pry`, `Rails`, and `WebConsole`). Additional methods can be added.\n\nSpecific default groups can be disabled if necessary:\n\nLint/Debugger:   WebConsole: ~"
        },
        "Style/ConstantVisibility": {
          "properties": {
            "IgnoreModules": {
              "type": "boolean",
              "description": "Default: false"
            }
          }
        },
        "Style/DoubleNegation": {
          "description": "This cop checks for uses of double negation (`!!`) to convert something to a boolean value.\n\nWhen using `EnforcedStyle: allowed_in_returns`, allow double negation in contexts that use boolean as a return value. When using `EnforcedStyle: forbidden`, double negation should be forbidden always.\n\nPlease, note that when something is a boolean value !!something and !something.nil? are not the same thing. As you're unlikely to write code that can accept values of any type this is rarely a problem in practice."
        },
        "Style/EvalWithLocation": {
          "properties": {
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop ensures that eval methods (`eval`, `instance_eval`, `class_eval` and `module_eval`) are given filename and line number values (`__FILE__` and `__LINE__`). This data is used to ensure that any errors raised within the evaluated code will be given the correct identification in a backtrace.\n\nThe cop also checks that the line number given relative to `__LINE__` is correct.\n\nThis cop will autocorrect incorrect or missing filename and line number values. However, if `eval` is called without a binding argument, the cop will not attempt to automatically add a binding, or add filename and line values.\n\nThis cop works only when a string literal is given as a code string. No offence is reported if a string variable is given as below:"
        },
        "Style/ExponentialNotation": {
          "description": "This cop enforces consistency when using exponential notation for numbers in the code (eg 1.2e4). Different styles are supported:\n\n - scientific which enforces a mantissa between 1 (inclusive) and 10 (exclusive).\n\n - engineering which enforces the exponent to be a multiple of 3 and the mantissa\nto be between 0.1 (inclusive) and 10 (exclusive).\n\n - integral which enforces the mantissa to always be a whole number without\ntrailing zeroes."
        },
        "Style/HashConversion": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks the usage of pre-2.1 `Hash[args]` method of converting enumerables and sequences of values to hashes."
        }
      }
    }
  },
  {
    "version": "1.11.0",
    "diff": {
      "properties": {
        "Style/EndlessMethod": {
          "description": "This cop checks for endless methods.\n\nIt can enforce either the use of endless methods definitions for single-lined method bodies, or disallow endless methods.\n\nOther method definition types are not considered by this cop.\n\nThe supported styles are:\n\n - allow_single_line (default) - only single line endless method definitions are allowed.\n\n - allow_always - all endless method definitions are allowed.\n\n - disallow - all endless method definitions are disallowed.\n\nIncorrect endless method definitions will always be corrected to a multi-line definition."
        },
        "Style/HashConversion": {
          "properties": {
            "AllowSplatArgument": {
              "type": "boolean",
              "description": "Default: true"
            }
          },
          "description": "This cop checks the usage of pre-2.1 `Hash[args]` method of converting enumerables and sequences of values to hashes.\n\nCorrection code from splat argument (`Hash[*ary]`) is not simply determined. For example, `Hash[*ary]` can be replaced with `ary.each_slice(2).to_h` but it will be complicated. So, `AllowSplatArgument` option is true by default to allow splat argument for simple code."
        },
        "Style/SymbolProc": {
          "properties": {
            "AllowMethodsWithArguments": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "Use symbols as procs when possible.\n\nIf you prefer a style that allows block for method with arguments, please set `true` to `AllowMethodsWithArguments`."
        },
        "Style/UnlessLogicalOperators": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "EnforcedStyle": {
              "enum": [
                "forbid_mixed_logical_operators",
                "forbid_logical_operators"
              ],
              "description": "Default: forbid_mixed_logical_operators"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: forbid_mixed_logical_operators, forbid_logical_operators"
            }
          },
          "description": "This cop checks for the use of logical operators in an `unless` condition. It discourages such code, as the condition becomes more difficult to read and understand.\n\nThis cop supports two styles: - `forbid_mixed_logical_operators` (default) - `forbid_logical_operators`\n\n`forbid_mixed_logical_operators` style forbids the use of more than one type of logical operators. This makes the `unless` condition easier to read because either all conditions need to be met or any condition need to be met in order for the expression to be truthy or falsey.\n\n`forbid_logical_operators` style forbids any use of logical operator. This makes it even more easy to read the `unless` condition as there is only one condition in the expression."
        }
      }
    }
  },
  {
    "version": "1.12.0",
    "diff": {
      "properties": {
        "Lint/SuppressedException": {
          "properties": {
            "AllowNil": {
              "type": "boolean",
              "description": "Default: true"
            }
          }
        },
        "Lint/SymbolConversion": {
          "properties": {
            "EnforcedStyle": {
              "enum": [
                "strict",
                "consistent"
              ],
              "description": "Default: strict"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: strict, consistent"
            }
          },
          "description": "This cop checks for uses of literal strings converted to a symbol where a literal symbol could be used instead.\n\nThere are two possible styles for this cop. `strict` (default) will register an offense for any incorrect usage. `consistent` additionally requires hashes to use the same style for every symbol key (ie. if any symbol key needs to be quoted it requires all keys to be quoted)."
        },
        "Naming/MemoizedInstanceVariableName": {
          "properties": {
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks for memoized methods whose instance variable name does not match the method name. Applies to both regular methods (defined with `def`) and dynamic methods (defined with `define_method` or `define_singleton_method`).\n\nThis cop can be configured with the EnforcedStyleForLeadingUnderscores directive. It can be configured to allow for memoized instance variables prefixed with an underscore. Prefixing ivars with an underscore is a convention that is used to implicitly indicate that an ivar should not be set or referenced outside of the memoization method.\n\nThis cop relies on the pattern `@instance_var ||= ...`, but this is sometimes used for other purposes than memoization so this cop is considered unsafe."
        },
        "Naming/RescuedExceptionsVariableName": {
          "description": "This cop makes sure that rescued exceptions variables are named as expected.\n\nThe `PreferredName` config option takes a `String`. It represents the required name of the variable. Its default is `e`.\n\nThis cop does not consider nested rescues because it cannot guarantee that the variable from the outer rescue is not used within the inner rescue (in which case, changing the inner variable would shadow the outer variable)."
        },
        "Style/Documentation": {
          "properties": {
            "AllowedConstants": {
              "type": "array",
              "description": "Default: []"
            }
          }
        },
        "Style/MethodCallWithArgsParentheses": {
          "properties": {
            "AllowParenthesesInStringInterpolation": {
              "type": "boolean",
              "description": "Default: false"
            }
          }
        },
        "Style/RedundantSelf": {
          "description": "This cop checks for redundant uses of `self`.\n\nThe usage of `self` is only needed when:\n\n - Sending a message to same object with zero arguments in\npresence of a method name clash with an argument or a local\nvariable.\n\n - Calling an attribute writer to prevent a local variable assignment.\n\nNote, with using explicit self you can only send messages with public or protected scope, you cannot send private messages this way.\n\nNote we allow uses of `self` with operators because it would be awkward otherwise."
        },
        "Style/StringChars": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "Safe": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "Checks for uses of `String#split` with empty string or regexp literal argument.\n\nThis cop is marked as unsafe. But probably it's quite unlikely that some other class would define a `split` method that takes exactly the same arguments."
        },
        "Style/TrailingBodyOnMethodDefinition": {
          "description": "This cop checks for trailing code after the method definition.\n\nIt always accepts endless method definitions that are basically on the same line."
        }
      }
    }
  },
  {
    "version": "1.12.1",
    "diff": {
      "properties": {
        "Style/FrozenStringLiteralComment": {
          "description": "This cop is designed to help you transition from mutable string literals to frozen string literals. It will add the comment `# frozen_string_literal: true` to the top of files to enable frozen string literals. Frozen string literals may be default in future Ruby. The comment will be added below a shebang and encoding comment."
        },
        "Style/MethodCallWithArgsParentheses": {
          "description": "This cop enforces the presence (default) or absence of parentheses in method calls containing parameters.\n\nIn the default style (require_parentheses), macro methods are ignored. Additional methods can be added to the `IgnoredMethods` or `IgnoredPatterns` list. These options are valid only in the default style. Macros can be included by either setting `IgnoreMacros` to false or adding specific macros to the `IncludedMacros` list.\n\nPrecedence of options is all follows:\n\n  1. IgnoredMethods\n\n  2. IgnoredPatterns\n\n  3. IncludedMacros\n\neg. If a method is listed in both `IncludedMacros` and `IgnoredMethods`, then the latter takes precedence (that is, the method is ignored).\n\nIn the alternative style (omit_parentheses), there are three additional options.\n\n  1. AllowParenthesesInChaining is false by default. Setting it to\ntrue allows the presence of parentheses in the last call during\nmethod chaining.\n\n  2. AllowParenthesesInMultilineCall is false by default. Setting it\nto true allows the presence of parentheses in multi-line method\ncalls.\n\n  3. AllowParenthesesInCamelCaseMethod is false by default. This\nallows the presence of parentheses when calling a method whose name\nbegins with a capital letter and which has no arguments. Setting it\nto true allows the presence of parentheses in such a method call\neven with arguments.\n\nParentheses are still allowed in cases where omitting them results in ambiguous or syntactically incorrect code. For example, parentheses are required around a method with arguments when inside an endless method definition introduced in Ruby 3.0.  Parentheses are also allowed when forwarding arguments with the triple-dot syntax introduced in Ruby 2.7 as omitting them starts an endless range."
        }
      }
    }
  },
  {
    "version": "1.13.0",
    "diff": {
      "properties": {
        "Bundler/GemComment": {
          "description": "Each gem in the Gemfile should have a comment explaining its purpose in the project, or the reason for its version or source.\n\nThe optional \"OnlyFor\" configuration array can be used to only register offenses when the gems use certain options or have version specifiers.\n\nWhen \"version_specifiers\" is included, a comment will be enforced if the gem has any version specifier.\n\nWhen \"restrictive_version_specifiers\" is included, a comment will be enforced if the gem has a version specifier that holds back the version of the gem.\n\nFor any other value in the array, a comment will be enforced for a gem if an option by the same name is present. A useful use case is to enforce a comment when using options that change the source of a gem:\n\n - bitbucket\n\n - gist\n\n - git\n\n - github\n\n - source\n\nFor a full list of options supported by bundler, see https://bundler.io/man/gemfile.5.html ."
        },
        "Layout/RedundantLineBreak": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "InspectBlocks": {
              "type": "boolean",
              "description": "Default: false"
            }
          },
          "description": "This cop checks whether certain expressions, e.g. method calls, that could fit completely on a single line, are broken up into multiple lines unnecessarily."
        },
        "Lint/AmbiguousBlockAssociation": {
          "properties": {
            "IgnoredMethods": {
              "type": "array",
              "description": "Default: []"
            }
          },
          "description": "This cop checks for ambiguous block association with method when param passed without parentheses.\n\nThis cop can customize ignored methods with `IgnoredMethods`."
        }
      }
    }
  },
  {
    "version": "1.14.0",
    "diff": {
      "properties": {
        "Bundler/GemVersion": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles",
              "description": "Default: **/*.gemfile, **/Gemfile, **/gems.rb"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "EnforcedStyle": {
              "enum": [
                "required",
                "forbidden"
              ],
              "description": "Default: required"
            },
            "AllowedGems": {
              "type": "array",
              "description": "Default: []"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: required, forbidden"
            }
          },
          "description": "Enforce that Gem version specifications are either required or forbidden."
        },
        "Layout/SingleLineBlockChain": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks if method calls are chained onto single line blocks. It considers that a line break before the dot improves the readability of the code."
        }
      }
    }
  },
  {
    "version": "1.15.0",
    "diff": {
      "properties": {
        "Lint/EmptyBlock": {
          "description": "This cop checks for blocks without a body. Such empty blocks are typically an oversight or we should provide a comment be clearer what we're aiming for.\n\nEmpty lambdas and procs are ignored by default.\n\nFor backwards compatibility, the configuration that allows/disallows empty lambdas and procs is called `AllowEmptyLambdas`, even though it also applies to procs."
        },
        "Style/NilLambda": {
          "description": "This cop checks for lambdas and procs that always return nil, which can be replaced with an empty lambda or proc instead."
        },
        "Style/TopLevelMethodDefinition": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: false"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "Newcomers to ruby applications may write top-level methods, when ideally they should be organized in appropriate classes or modules. This cop looks for definitions of top-level methods and warns about them.\n\nHowever for ruby scripts it is perfectly fine to use top-level methods. Hence this cop is disabled by default."
        },
        "Style/TrivialAccessors": {
          "properties": {
            "AllowDSLWriters": {
              "description": "Default: true"
            }
          }
        }
      }
    }
  },
  {
    "version": "1.16.0",
    "diff": {
      "properties": {
        "Layout/CaseIndentation": {
          "description": "This cop checks how the `when` and `in`s of a `case` expression are indented in relation to its `case` or `end` keyword.\n\nIt will register a separate offense for each misaligned `when` and `in`."
        },
        "Lint/EmptyInPattern": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            }
          },
          "description": "This cop checks for the presence of `in` pattern branches without a body."
        },
        "Style/HashEachMethods": {
          "properties": {
            "AllowedReceivers": {
              "type": "array",
              "description": "Default: []"
            }
          }
        },
        "Style/IdenticalConditionalBranches": {
          "properties": {
            "AutoCorrect": {
              "type": "boolean"
            }
          }
        },
        "Style/InPatternThen": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks for `in;` uses in `case` expressions."
        },
        "Style/MultilineInPatternThen": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            }
          },
          "description": "This cop checks uses of the `then` keyword in multi-line `in` statement."
        },
        "Style/QuotedSymbols": {
          "type": "object",
          "additionalProperties": true,
          "propertyNames": {
            "$ref": "#/definitions/attributeName"
          },
          "properties": {
            "Enabled": {
              "type": "boolean",
              "description": "Default: pending"
            },
            "Exclude": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Include": {
              "$ref": "#/definitions/listOfFiles"
            },
            "Severity": {
              "$ref": "#/definitions/severity"
            },
            "Details": {
              "type": "string"
            },
            "StyleGuideBaseURL": {
              "type": "string"
            },
            "StyleGuide": {
              "type": "string"
            },
            "AutoCorrect": {
              "type": "boolean"
            },
            "EnforcedStyle": {
              "enum": [
                "same_as_string_literals",
                "single_quotes",
                "double_quotes"
              ],
              "description": "Default: same_as_string_literals"
            },
            "SupportedStyles": {
              "type": "array",
              "description": "Default: same_as_string_literals, single_quotes, double_quotes"
            }
          },
          "description": "Checks if the quotes used for quoted symbols match the configured defaults. By default uses the same configuration as `Style/StringLiterals`.\n\nString interpolation is always kept in double quotes.\n\nNote: `Lint/SymbolConversion` can be used in parallel to ensure that symbols are not quoted that don't need to be. This cop is for configuring the quoting style to use for symbols that require quotes."
        }
      }
    }
  }
]